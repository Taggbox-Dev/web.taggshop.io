{"version":3,"file":"static/js/741.9588c4d9.chunk.js","mappings":"gIAOA,IAAIA,EAAe,WAAc,SAASC,EAAiBC,EAAQC,GAAS,IAAK,IAAIC,EAAI,EAAGA,EAAID,EAAME,OAAQD,IAAK,CAAE,IAAIE,EAAaH,EAAMC,GAAIE,EAAWC,WAAaD,EAAWC,aAAc,EAAOD,EAAWE,cAAe,EAAU,UAAWF,IAAYA,EAAWG,UAAW,GAAMC,OAAOC,eAAeT,EAAQI,EAAWM,IAAKN,EAAa,CAAE,CAAE,OAAO,SAAUO,EAAaC,EAAYC,GAAiJ,OAA9HD,GAAYb,EAAiBY,EAAYG,UAAWF,GAAiBC,GAAad,EAAiBY,EAAaE,GAAqBF,CAAa,CAAG,CAA7hB,GAEfI,EAASC,EAAQ,OAEjBC,EAAUC,EAAuBH,GAIjCI,EAAcD,EAFDF,EAAQ,QAIrBI,EAASJ,EAAQ,OAIjBK,EAAiBH,EAFDF,EAAQ,OAMxBM,EAAaJ,EAFDF,EAAQ,QAMpBO,EAAaL,EAFDF,EAAQ,QAIxB,SAASE,EAAuBM,GAAO,OAAOA,GAAOA,EAAIC,WAAaD,EAAM,CAAEE,QAASF,EAAO,CAE9F,SAASG,EAAgBC,EAAUjB,GAAe,KAAMiB,aAAoBjB,GAAgB,MAAM,IAAIkB,UAAU,oCAAwC,CAExJ,SAASC,EAA2BC,EAAMC,GAAQ,IAAKD,EAAQ,MAAM,IAAIE,eAAe,6DAAgE,OAAOD,GAAyB,kBAATA,GAAqC,oBAATA,EAA8BD,EAAPC,CAAa,CAE/O,SAASE,EAAUC,EAAUC,GAAc,GAA0B,oBAAfA,GAA4C,OAAfA,EAAuB,MAAM,IAAIP,UAAU,kEAAoEO,GAAeD,EAASrB,UAAYN,OAAO6B,OAAOD,GAAcA,EAAWtB,UAAW,CAAEwB,YAAa,CAAEC,MAAOJ,EAAU9B,YAAY,EAAOE,UAAU,EAAMD,cAAc,KAAe8B,IAAY5B,OAAOgC,eAAiBhC,OAAOgC,eAAeL,EAAUC,GAAcD,EAASM,UAAYL,EAAY,CAK7e,IAAIM,EACG,EADHA,EAII,EAJJA,EAKK,EALLA,EAMM,EAENC,EAAc,yBACdC,EAAY,GACZC,EAAU,GAGVC,GAAwB,EAC5B,IACE,IAAIC,EAAOvC,OAAOC,eAAe,CAAC,EAAG,UAAW,CAC9CuC,IAAK,WACHF,GAAwB,CAC1B,IAEFG,OAAOC,iBAAiB,OAAQ,KAAMH,EACxC,CAAE,MAAOI,GAAI,CAGb,IAAIC,IAAeN,GAAwB,CAAEO,SAAS,EAAOC,SAAS,GAwGlEC,EAAe,SAAsBC,GACvC,IAAIC,EAAOD,EAAUE,IACrB,GAAMD,aAAgBE,YAAtB,CAIA,IAAIC,GAAS,EAAIvC,EAAeK,SAAS+B,GAErCI,EADaL,EAAUvD,MAAM6D,UAAYF,IAAWH,EAAKM,eAAiBH,IAAWI,UAAYJ,IAAWI,SAASC,gBAvGhG,SAA8BT,EAAWI,GAClE,IAAIH,EAAOD,EAAUE,IAEjBQ,OAAY,EACZC,OAAa,EACbC,OAAe,EACfC,OAAc,EAElB,IACE,IAAIC,EAAwBV,EAAOW,wBAEnCL,EAAYI,EAAsBE,IAClCL,EAAaG,EAAsBG,KACnCL,EAAeE,EAAsBI,OACrCL,EAAcC,EAAsBK,KACtC,CAAE,MAAOxB,GACPe,EAAYxB,EACZyB,EAAazB,EACb0B,EAAe1B,EACf2B,EAAc3B,CAChB,CAEA,IAAIkC,EAAoB3B,OAAO4B,aAAeb,SAASC,gBAAgBa,aACnEC,EAAmB9B,OAAO+B,YAAchB,SAASC,gBAAgBgB,YAGjEC,EAAkBC,KAAKC,IAAIlB,EAAW,GACtCmB,EAAmBF,KAAKC,IAAIjB,EAAY,GACxCmB,EAAqBH,KAAKI,IAAIX,EAAmBV,EAAYE,GAAgBc,EAC7EM,EAAoBL,KAAKI,IAAIR,EAAkBZ,EAAaE,GAAegB,EAG3Eb,OAAM,EACNC,OAAO,EACPC,OAAS,EACTC,OAAQ,EAEZ,IACE,IAAIc,EAAwBhC,EAAKc,wBAEjCC,EAAMiB,EAAsBjB,IAC5BC,EAAOgB,EAAsBhB,KAC7BC,EAASe,EAAsBf,OAC/BC,EAAQc,EAAsBd,KAChC,CAAE,MAAOxB,GACPqB,EAAM9B,EACN+B,EAAO/B,EACPgC,EAAShC,EACTiC,EAAQjC,CACV,CAEA,IAAIgD,EAAYlB,EAAMU,EAClBS,EAAalB,EAAOY,EAEpBO,EAAUC,MAAMC,QAAQtC,EAAUvD,MAAM8F,QAAUvC,EAAUvD,MAAM8F,OAAS,CAACvC,EAAUvD,MAAM8F,OAAQvC,EAAUvD,MAAM8F,QAExH,OAAOL,EAAYE,EAAQ,IAAMN,GAAsBI,EAAYhB,EAASkB,EAAQ,IAAM,GAAKD,EAAaC,EAAQ,IAAMJ,GAAqBG,EAAahB,EAAQiB,EAAQ,IAAM,CACpL,CA+C6BI,CAAqBxC,EAAWI,GAxCpC,SAA4BJ,GACnD,IAAIC,EAAOD,EAAUE,IAGrB,KAAMD,EAAKwC,aAAexC,EAAKyC,cAAgBzC,EAAK0C,iBAAiBhG,QAAS,OAAO,EAErF,IAAIqE,OAAM,EACN4B,OAAgB,EAEpB,IACE,IAAIC,EAAyB5C,EAAKc,wBAElCC,EAAM6B,EAAuB7B,IAC7B4B,EAAgBC,EAAuB3B,MACzC,CAAE,MAAOvB,GACPqB,EAAM9B,EACN0D,EAAgB1D,CAClB,CAEA,IAAIkC,EAAoB3B,OAAO4B,aAAeb,SAASC,gBAAgBa,aAEnEc,EAAUC,MAAMC,QAAQtC,EAAUvD,MAAM8F,QAAUvC,EAAUvD,MAAM8F,OAAS,CAACvC,EAAUvD,MAAM8F,OAAQvC,EAAUvD,MAAM8F,QAExH,OAAOvB,EAAMoB,EAAQ,IAAMhB,GAAqBJ,EAAM4B,EAAgBR,EAAQ,IAAM,CACtF,CAgBuEU,CAAmB9C,GACpFK,EAEGL,EAAUK,UACTL,EAAUvD,MAAMsG,MAClB1D,EAAQ2D,KAAKhD,GAGfA,EAAUK,SAAU,EACpBL,EAAUiD,eAEDjD,EAAUvD,MAAMsG,MAAQ/C,EAAUK,UAC7CL,EAAUK,SAAU,EAChBL,EAAUvD,MAAMyG,oBAClBlD,EAAUiD,cAlBd,CAqBF,EAEIE,EAAe,WACjB9D,EAAQ+D,SAAQ,SAAUpD,GACxB,IAAIqD,EAAQjE,EAAUkE,QAAQtD,IACf,IAAXqD,GACFjE,EAAUmE,OAAOF,EAAO,EAE5B,IAEAhE,EAAU,EACZ,EAEImE,EAAkB,WACpB,IAAK,IAAI9G,EAAI,EAAGA,EAAI0C,EAAUzC,SAAUD,EAAG,CACzC,IAAI+G,EAAWrE,EAAU1C,GACzBqD,EAAa0D,EACf,CAEAN,GACF,EAgBIO,OAAY,EACZC,EAAuB,KAMvBC,EAAW,SAAUC,GAGvB,SAASD,EAASnH,GAChB0B,EAAgB2F,KAAMF,GAEtB,IAAIG,EAAQzF,EAA2BwF,MAAOF,EAAS3E,WAAajC,OAAOgH,eAAeJ,IAAWpF,KAAKsF,KAAMrH,IAIhH,OAFAsH,EAAM1D,SAAU,EAChB0D,EAAME,OAASF,EAAME,OAAOC,KAAKH,GAC1BA,CACT,CA2HA,OArIArF,EAAUkF,EAAUC,GAYpBvH,EAAasH,EAAU,CAAC,CACtB1G,IAAK,oBACL6B,MAAO,WAGL,IAAIoF,EAAa1E,OACb2E,EAAkBN,KAAKrH,MAAM2H,gBAE7BA,GAxBiB,kBAyBNA,IACXD,EAAaA,EAAW3D,SAAS6D,cAAcD,IAGnD,IAAIE,OAAwDC,IAAxBT,KAAKrH,MAAM+H,UAAwC,aAAdd,GAA0C,aAAdA,QAAoDa,IAAxBT,KAAKrH,MAAM+H,SAoB5I,GAlBIF,KACF,EAAI1G,EAAO6G,KAAKN,EAAY,SAAUR,EAAsB/D,IAC5D,EAAIhC,EAAO6G,KAAKhF,OAAQ,SAAUkE,EAAsB/D,GACxD+D,EAAuB,MAGpBA,SACyBY,IAAxBT,KAAKrH,MAAM+H,UACbb,GAAuB,EAAI7F,EAAWI,SAASsF,EAAgD,kBAAxBM,KAAKrH,MAAM+H,SAAwBV,KAAKrH,MAAM+H,SAAW,KAChId,EAAY,iBACqBa,IAAxBT,KAAKrH,MAAMiI,UACpBf,GAAuB,EAAI5F,EAAWG,SAASsF,EAAgD,kBAAxBM,KAAKrH,MAAMiI,SAAwBZ,KAAKrH,MAAMiI,SAAW,KAChIhB,EAAY,YAEZC,EAAuBH,GAIvBM,KAAKrH,MAAM6D,SAAU,CACvB,IAAIF,GAAS,EAAIvC,EAAeK,SAAS4F,KAAK5D,KAC9C,GAAIE,GAAyC,oBAAxBA,EAAOuE,aAA6B,CACvD,IAAIC,GAAqBxE,EAAOuE,aAAaxF,GAAzB,EACE,IAAlByF,GACFxE,EAAOV,iBAAiB,SAAUiE,EAAsB/D,GAE1DQ,EAAOyE,aAAa1F,EAAayF,EACnC,CACF,MAAO,GAAyB,IAArBxF,EAAUzC,QAAgB2H,EAA+B,CAClE,IAAIQ,EAAShB,KAAKrH,MACdsI,EAASD,EAAOC,OAChBC,EAASF,EAAOE,OAGhBD,IACF,EAAInH,EAAOqH,IAAId,EAAY,SAAUR,EAAsB/D,GAGzDoF,IACF,EAAIpH,EAAOqH,IAAIxF,OAAQ,SAAUkE,EAAsB/D,EAE3D,CAEAR,EAAU4D,KAAKc,MACf/D,EAAa+D,KACf,GACC,CACD5G,IAAK,wBACL6B,MAAO,WACL,OAAO+E,KAAKzD,OACd,GACC,CACDnD,IAAK,uBACL6B,MAAO,WACL,GAAI+E,KAAKrH,MAAM6D,SAAU,CACvB,IAAIF,GAAS,EAAIvC,EAAeK,SAAS4F,KAAK5D,KAC9C,GAAIE,GAAyC,oBAAxBA,EAAOuE,aAA6B,CACvD,IAAIC,GAAiBxE,EAAOuE,aAAaxF,GAAe,EAClC,IAAlByF,GACFxE,EAAO8E,oBAAoB,SAAUvB,EAAsB/D,GAC3DQ,EAAO+E,gBAAgBhG,IAEvBiB,EAAOyE,aAAa1F,EAAayF,EAErC,CACF,CAEA,IAAIvB,EAAQjE,EAAUkE,QAAQQ,OACf,IAAXT,GACFjE,EAAUmE,OAAOF,EAAO,GAGD,IAArBjE,EAAUzC,QAAkC,qBAAX8C,UACnC,EAAI7B,EAAO6G,KAAKhF,OAAQ,SAAUkE,EAAsB/D,IACxD,EAAIhC,EAAO6G,KAAKhF,OAAQ,SAAUkE,EAAsB/D,GAE5D,GACC,CACD1C,IAAK,SACL6B,MAAO,SAAgBqG,GACjBA,IACFtB,KAAK5D,IAAMkF,EAEf,GACC,CACDlI,IAAK,SACL6B,MAAO,WACL,IAAIsG,EAAUvB,KAAKrH,MACfyE,EAASmE,EAAQnE,OACjBoE,EAAWD,EAAQC,SACnBC,EAAcF,EAAQE,YACtBC,EAAYH,EAAQG,UACpBC,EAAkBJ,EAAQI,gBAC1BC,EAAQL,EAAQK,MAGpB,OAAOjI,EAAQS,QAAQyH,cACrB,MACA,CAAEH,UAAWC,EAAkB,YAAcD,EAAWtF,IAAK4D,KAAKG,OAAQyB,MAAOA,GACjF5B,KAAKzD,QAAUiF,EAAWC,GAA4B9H,EAAQS,QAAQyH,cAAc,MAAO,CACzFD,MAAO,CAAExE,OAAQA,GACjBsE,UAAWC,EAAkB,iBAGnC,KAGK7B,CACT,CAvIe,CAuIbrG,EAAOqI,WAEThC,EAASiC,UAAY,CACnBL,UAAW7H,EAAYO,QAAQ4H,OAC/BL,gBAAiB9H,EAAYO,QAAQ4H,OACrC/C,KAAMpF,EAAYO,QAAQ6H,KAC1B7E,OAAQvD,EAAYO,QAAQ8H,UAAU,CAACrI,EAAYO,QAAQ+H,OAAQtI,EAAYO,QAAQ4H,SACvFvD,OAAQ5E,EAAYO,QAAQ8H,UAAU,CAACrI,EAAYO,QAAQ+H,OAAQtI,EAAYO,QAAQgI,QAAQvI,EAAYO,QAAQ+H,UACnH3F,SAAU3C,EAAYO,QAAQ6H,KAC9Bf,OAAQrH,EAAYO,QAAQ6H,KAC5BhB,OAAQpH,EAAYO,QAAQ6H,KAC5BT,SAAU3H,EAAYO,QAAQ+B,KAC9ByE,SAAU/G,EAAYO,QAAQ8H,UAAU,CAACrI,EAAYO,QAAQ+H,OAAQtI,EAAYO,QAAQ6H,OACzFvB,SAAU7G,EAAYO,QAAQ8H,UAAU,CAACrI,EAAYO,QAAQ+H,OAAQtI,EAAYO,QAAQ6H,OACzFR,YAAa5H,EAAYO,QAAQ+B,KACjCmE,gBAAiBzG,EAAYO,QAAQ8H,UAAU,CAACrI,EAAYO,QAAQ4H,OAAQnI,EAAYO,QAAQiI,SAChGjD,mBAAoBvF,EAAYO,QAAQ6H,KACxCL,MAAO/H,EAAYO,QAAQiI,QAG7BvC,EAASwC,aAAe,CACtBZ,UAAW,GACXC,gBAAiB,WACjB1C,MAAM,EACNR,OAAQ,EACRjC,UAAU,EACV0E,QAAQ,EACRD,QAAQ,EACR7B,oBAAoB,GAuCtBmD,EAAQ,GAAUzC,C,gBCtblB5G,OAAOC,eAAeoJ,EAAS,aAAc,CAC3CtH,OAAO,IAETsH,EAAAA,QACA,SAAkBC,EAAMC,EAAMC,GAC5B,IAAIC,OAAU,EACVC,OAAO,EACPC,OAAU,EACVC,OAAY,EACZC,OAAS,EAETC,EAAQ,SAASA,IACnB,IAAIC,GAAQ,IAAIC,KAASJ,EAErBG,EAAOR,GAAQQ,GAAQ,EACzBN,EAAUQ,WAAWH,EAAOP,EAAOQ,IAEnCN,EAAU,KACLD,IACHK,EAASP,EAAKY,MAAMP,EAASD,GACxBD,IACHE,EAAU,KACVD,EAAO,OAIf,EAEA,OAAO,WACLC,EAAU7C,KACV4C,EAAOS,UACPP,GAAa,IAAII,KAEjB,IAAII,EAAUZ,IAAcC,EAW5B,OAVKA,IACHA,EAAUQ,WAAWH,EAAOP,IAG1Ba,IACFP,EAASP,EAAKY,MAAMP,EAASD,GAC7BC,EAAU,KACVD,EAAO,MAGFG,CACT,CACF,C,gBC9CA7J,OAAOC,eAAeoJ,EAAS,aAAc,CAC3CtH,OAAO,IAETsH,EAAQpB,GAER,SAAYoC,EAAIC,EAAWC,EAAUhI,GACnCA,EAAOA,IAAQ,EACX8H,EAAG3H,iBACL2H,EAAG3H,iBAAiB4H,EAAWC,EAAUhI,GAChC8H,EAAGG,aACZH,EAAGG,YAAY,KAAOF,GAAW,SAAU3H,GACzC4H,EAAS/I,KAAK6I,EAAI1H,GAAKF,OAAOgI,MAChC,GAEJ,EAVApB,EAAQ5B,IAYR,SAAa4C,EAAIC,EAAWC,EAAUhI,GACpCA,EAAOA,IAAQ,EACX8H,EAAGnC,oBACLmC,EAAGnC,oBAAoBoC,EAAWC,EAAUhI,GACnC8H,EAAGK,aACZL,EAAGK,YAAY,KAAOJ,EAAWC,EAErC,C,eCvBAvK,OAAOC,eAAeoJ,EAAS,aAAc,CAC3CtH,OAAO,IAOTsH,EAAAA,QAAkB,SAAUpG,GAC1B,KAAMA,aAAgBE,aACpB,OAAOK,SAASC,gBAOlB,IAJA,IAAIkH,EAA8C,aAAxB1H,EAAKyF,MAAMkC,SACjCC,EAAgB,gBAChBzH,EAASH,EAENG,GAAQ,CACb,IAAKA,EAAO0H,WACV,OAAO7H,EAAKM,eAAiBC,SAASC,gBAGxC,IAAIiF,EAAQjG,OAAOsI,iBAAiB3H,GAChCwH,EAAWlC,EAAMkC,SACjBtH,EAAWoF,EAAMpF,SACjB0H,EAAYtC,EAAM,cAClBuC,EAAYvC,EAAM,cAEtB,GAAiB,WAAbkC,GAAyBD,EAC3BvH,EAASA,EAAO0H,eADlB,CAKA,GAAID,EAAcK,KAAK5H,IAAauH,EAAcK,KAAKF,IAAcH,EAAcK,KAAKD,GACtF,OAAO7H,EAGTA,EAASA,EAAO0H,UANhB,CAOF,CAEA,OAAO7H,EAAKM,eAAiBN,EAAKQ,iBAAmBD,SAASC,eAChE,C,gBCzCAzD,OAAOC,eAAeoJ,EAAS,aAAc,CAC3CtH,OAAO,IAETsH,EAAAA,QAEA,SAAkB8B,EAAIC,EAAYC,GAEhC,IAAItB,EAAMuB,EACV,OAFAF,IAAeA,EAAa,KAErB,WACL,IAAIzB,EAAU0B,GAASvE,KAEnByE,GAAO,IAAIvB,KACXN,EAAOS,UACPJ,GAAQwB,EAAMxB,EAAOqB,GAEvBI,aAAaF,GACbA,EAAarB,YAAW,WACtBF,EAAOwB,EACPJ,EAAGjB,MAAMP,EAASD,EACpB,GAAG0B,KAEHrB,EAAOwB,EACPJ,EAAGjB,MAAMP,EAASD,GAEtB,CACF,C,gQCvBA,SAAS+B,EAAWC,GAClB,IAAI,OACFC,EAAM,aACNC,EAAY,GACZ3D,EAAE,KACF4D,GACEH,EACJ,MAAMjJ,GAASqJ,EAAAA,EAAAA,KAiBf,IAAIrC,EAhBJmC,EAAa,CACXG,WAAY,CACVC,SAAS,EACTC,gBAAgB,EAChBC,QAAQ,EACRC,aAAa,EACbC,YAAa,EACbC,aAAc,YACdC,eAAgB,KAChBC,cAAe,KACfC,kBAAmB,0BAGvBb,EAAOI,WAAa,CAClBC,SAAS,GAGX,IACIS,EADAC,GAAiBnB,EAAAA,EAAAA,KAErB,MAAMoB,EAAoB,GAqE1B,SAASC,IACFjB,EAAOK,UACZL,EAAOkB,cAAe,EACxB,CACA,SAASC,IACFnB,EAAOK,UACZL,EAAOkB,cAAe,EACxB,CACA,SAASE,EAAcC,GACrB,QAAIrB,EAAOsB,OAAOlB,WAAWO,gBAAkBU,EAASE,MAAQvB,EAAOsB,OAAOlB,WAAWO,oBAIrFX,EAAOsB,OAAOlB,WAAWQ,gBAAiBhB,EAAAA,EAAAA,KAAQmB,EAAiBf,EAAOsB,OAAOlB,WAAWQ,iBAQ5FS,EAASE,OAAS,IAAK3B,EAAAA,EAAAA,KAAQmB,EAAiB,KAgBhDM,EAASG,UAAY,EACjBxB,EAAOyB,QAASzB,EAAOsB,OAAOI,MAAU1B,EAAO2B,YACnD3B,EAAO4B,YACP1B,EAAK,SAAUmB,EAASQ,MAEf7B,EAAO8B,cAAe9B,EAAOsB,OAAOI,MAAU1B,EAAO2B,YAChE3B,EAAO+B,YACP7B,EAAK,SAAUmB,EAASQ,MAG1Bd,GAAiB,IAAIjK,EAAOuH,MAAO2D,WAE5B,IACT,CAcA,SAASC,EAAOnD,GACd,IAAI9H,EAAI8H,EACJoD,GAAsB,EAC1B,IAAKlC,EAAOK,QAAS,OAGrB,GAAIvB,EAAMjL,OAAOsO,QAAQ,IAADC,OAAKpC,EAAOsB,OAAOlB,WAAWS,oBAAsB,OAC5E,MAAMS,EAAStB,EAAOsB,OAAOlB,WACzBJ,EAAOsB,OAAOe,SAChBrL,EAAEsL,iBAEJ,IAAIC,EAAWvC,EAAOtB,GACwB,cAA1CsB,EAAOsB,OAAOlB,WAAWM,eAC3B6B,EAAW1K,SAAS6D,cAAcsE,EAAOsB,OAAOlB,WAAWM,eAE7D,MAAM8B,EAAyBD,GAAYA,EAASE,SAASzL,EAAEnD,QAC/D,IAAKmM,EAAOkB,eAAiBsB,IAA2BlB,EAAOhB,eAAgB,OAAO,EAClFtJ,EAAE0L,gBAAe1L,EAAIA,EAAE0L,eAC3B,IAAInB,EAAQ,EACZ,MAAMoB,EAAY3C,EAAO4C,cAAgB,EAAI,EACvCC,EAxJR,SAAmB7L,GAKjB,IAAI8L,EAAK,EACLC,EAAK,EACLC,EAAK,EACLC,EAAK,EAqDT,MAlDI,WAAYjM,IACd+L,EAAK/L,EAAEkM,QAEL,eAAgBlM,IAClB+L,GAAM/L,EAAEmM,WAAa,KAEnB,gBAAiBnM,IACnB+L,GAAM/L,EAAEoM,YAAc,KAEpB,gBAAiBpM,IACnB8L,GAAM9L,EAAEqM,YAAc,KAIpB,SAAUrM,GAAKA,EAAEsM,OAAStM,EAAEuM,kBAC9BT,EAAKC,EACLA,EAAK,GAEPC,EA3BmB,GA2BdF,EACLG,EA5BmB,GA4BdF,EACD,WAAY/L,IACdiM,EAAKjM,EAAEwM,QAEL,WAAYxM,IACdgM,EAAKhM,EAAEyM,QAELzM,EAAE0M,WAAaV,IAEjBA,EAAKC,EACLA,EAAK,IAEFD,GAAMC,IAAOjM,EAAE2M,YACE,IAAhB3M,EAAE2M,WAEJX,GA1CgB,GA2ChBC,GA3CgB,KA8ChBD,GA7CgB,IA8ChBC,GA9CgB,MAmDhBD,IAAOF,IACTA,EAAKE,EAAK,GAAK,EAAI,GAEjBC,IAAOF,IACTA,EAAKE,EAAK,GAAK,EAAI,GAEd,CACLW,MAAOd,EACPe,MAAOd,EACPe,OAAQd,EACRe,OAAQd,EAEZ,CAqFee,CAAUhN,GACvB,GAAIsK,EAAOd,YACT,GAAIR,EAAOiE,eAAgB,CACzB,KAAIjL,KAAKkL,IAAIrB,EAAKiB,QAAU9K,KAAKkL,IAAIrB,EAAKkB,SAA+C,OAAO,EAA7CxC,GAASsB,EAAKiB,OAASnB,CAC5E,KAAO,MAAI3J,KAAKkL,IAAIrB,EAAKkB,QAAU/K,KAAKkL,IAAIrB,EAAKiB,SAAmC,OAAO,EAAjCvC,GAASsB,EAAKkB,MAAuB,MAE/FxC,EAAQvI,KAAKkL,IAAIrB,EAAKiB,QAAU9K,KAAKkL,IAAIrB,EAAKkB,SAAWlB,EAAKiB,OAASnB,GAAaE,EAAKkB,OAE3F,GAAc,IAAVxC,EAAa,OAAO,EACpBD,EAAOf,SAAQgB,GAASA,GAG5B,IAAI4C,EAAYnE,EAAOoE,eAAiB7C,EAAQD,EAAOb,YAavD,GAZI0D,GAAanE,EAAOqE,iBAAgBF,EAAYnE,EAAOqE,gBACvDF,GAAanE,EAAOsE,iBAAgBH,EAAYnE,EAAOsE,gBAS3DpC,IAAsBlC,EAAOsB,OAAOI,QAAgByC,IAAcnE,EAAOqE,gBAAkBF,IAAcnE,EAAOsE,gBAC5GpC,GAAuBlC,EAAOsB,OAAOiD,QAAQvN,EAAEwN,kBAC9CxE,EAAOsB,OAAOmD,UAAazE,EAAOsB,OAAOmD,SAASpE,QAoChD,CAOL,MAAMgB,EAAW,CACfqD,MAAM9E,EAAAA,EAAAA,KACN2B,MAAOvI,KAAKkL,IAAI3C,GAChBC,UAAWxI,KAAK2L,KAAKpD,IAEjBqD,EAAoB9D,GAAuBO,EAASqD,KAAO5D,EAAoB4D,KAAO,KAAOrD,EAASE,OAAST,EAAoBS,OAASF,EAASG,YAAcV,EAAoBU,UAC7L,IAAKoD,EAAmB,CACtB9D,OAAsBlF,EACtB,IAAIqD,EAAWe,EAAOoE,eAAiB7C,EAAQD,EAAOb,YACtD,MAAMoE,EAAe7E,EAAO8B,YACtBgD,EAAS9E,EAAOyB,MAiBtB,GAhBIxC,GAAYe,EAAOqE,iBAAgBpF,EAAWe,EAAOqE,gBACrDpF,GAAYe,EAAOsE,iBAAgBrF,EAAWe,EAAOsE,gBACzDtE,EAAO+E,cAAc,GACrB/E,EAAOgF,aAAa/F,GACpBe,EAAOiF,iBACPjF,EAAOkF,oBACPlF,EAAOmF,wBACFN,GAAgB7E,EAAO8B,cAAgBgD,GAAU9E,EAAOyB,QAC3DzB,EAAOmF,sBAELnF,EAAOsB,OAAOI,MAChB1B,EAAOoF,QAAQ,CACb5D,UAAWH,EAASG,UAAY,EAAI,OAAS,OAC7C6D,cAAc,IAGdrF,EAAOsB,OAAOmD,SAASa,OAAQ,CAYjCzF,aAAa/B,GACbA,OAAUlC,EACNoF,EAAkBhN,QAAU,IAC9BgN,EAAkBuE,QAGpB,MAAMC,EAAYxE,EAAkBhN,OAASgN,EAAkBA,EAAkBhN,OAAS,QAAK4H,EACzF6J,EAAazE,EAAkB,GAErC,GADAA,EAAkB3G,KAAKgH,GACnBmE,IAAcnE,EAASE,MAAQiE,EAAUjE,OAASF,EAASG,YAAcgE,EAAUhE,WAErFR,EAAkBpG,OAAO,QACpB,GAAIoG,EAAkBhN,QAAU,IAAMqN,EAASqD,KAAOe,EAAWf,KAAO,KAAOe,EAAWlE,MAAQF,EAASE,OAAS,GAAKF,EAASE,OAAS,EAAG,CAOnJ,MAAMmE,EAAkBnE,EAAQ,EAAI,GAAM,GAC1CT,EAAsBO,EACtBL,EAAkBpG,OAAO,GACzBkD,GAAU6H,EAAAA,EAAAA,IAAS,KACjB3F,EAAO4F,eAAe5F,EAAOsB,OAAOuE,OAAO,OAAMjK,EAAW8J,EAAgB,GAC3E,EACL,CAEK5H,IAIHA,GAAU6H,EAAAA,EAAAA,IAAS,KAEjB7E,EAAsBO,EACtBL,EAAkBpG,OAAO,GACzBoF,EAAO4F,eAAe5F,EAAOsB,OAAOuE,OAAO,OAAMjK,EAHzB,GAGoD,GAC3E,KAEP,CAQA,GALKgJ,GAAmB1E,EAAK,SAAUlJ,GAGnCgJ,EAAOsB,OAAOwE,UAAY9F,EAAOsB,OAAOyE,8BAA8B/F,EAAO8F,SAASE,OAEtF1E,EAAOhB,iBAAmBrB,IAAae,EAAOqE,gBAAkBpF,IAAae,EAAOsE,gBACtF,OAAO,CAEX,CACF,KApIgE,CAE9D,MAAMjD,EAAW,CACfqD,MAAM9E,EAAAA,EAAAA,KACN2B,MAAOvI,KAAKkL,IAAI3C,GAChBC,UAAWxI,KAAK2L,KAAKpD,GACrBM,IAAK/C,GAIHkC,EAAkBhN,QAAU,GAC9BgN,EAAkBuE,QAGpB,MAAMC,EAAYxE,EAAkBhN,OAASgN,EAAkBA,EAAkBhN,OAAS,QAAK4H,EAmB/F,GAlBAoF,EAAkB3G,KAAKgH,GAQnBmE,GACEnE,EAASG,YAAcgE,EAAUhE,WAAaH,EAASE,MAAQiE,EAAUjE,OAASF,EAASqD,KAAOc,EAAUd,KAAO,MACrHtD,EAAcC,GAGhBD,EAAcC,GAtFpB,SAAuBA,GACrB,MAAMC,EAAStB,EAAOsB,OAAOlB,WAC7B,GAAIiB,EAASG,UAAY,GACvB,GAAIxB,EAAOyB,QAAUzB,EAAOsB,OAAOI,MAAQJ,EAAOhB,eAEhD,OAAO,OAEJ,GAAIN,EAAO8B,cAAgB9B,EAAOsB,OAAOI,MAAQJ,EAAOhB,eAE7D,OAAO,EAET,OAAO,CACT,CA+EQ2F,CAAc5E,GAChB,OAAO,CAEX,CAkGA,OADIrK,EAAEsL,eAAgBtL,EAAEsL,iBAAsBtL,EAAEkP,aAAc,GACvD,CACT,CACA,SAASC,EAAOC,GACd,IAAI7D,EAAWvC,EAAOtB,GACwB,cAA1CsB,EAAOsB,OAAOlB,WAAWM,eAC3B6B,EAAW1K,SAAS6D,cAAcsE,EAAOsB,OAAOlB,WAAWM,eAE7D6B,EAAS6D,GAAQ,aAAcnF,GAC/BsB,EAAS6D,GAAQ,aAAcjF,GAC/BoB,EAAS6D,GAAQ,QAASnE,EAC5B,CACA,SAASoE,IACP,OAAIrG,EAAOsB,OAAOe,SAChBrC,EAAOsG,UAAU/J,oBAAoB,QAAS0F,IACvC,IAELjC,EAAOI,WAAWC,UACtB8F,EAAO,oBACPnG,EAAOI,WAAWC,SAAU,GACrB,EACT,CACA,SAASkG,IACP,OAAIvG,EAAOsB,OAAOe,SAChBrC,EAAOsG,UAAUvP,iBAAiB+H,MAAOmD,IAClC,KAEJjC,EAAOI,WAAWC,UACvB8F,EAAO,uBACPnG,EAAOI,WAAWC,SAAU,GACrB,EACT,CACA/D,EAAG,QAAQ,MACJ0D,EAAOsB,OAAOlB,WAAWC,SAAWL,EAAOsB,OAAOe,SACrDkE,IAEEvG,EAAOsB,OAAOlB,WAAWC,SAASgG,GAAQ,IAEhD/J,EAAG,WAAW,KACR0D,EAAOsB,OAAOe,SAChBgE,IAEErG,EAAOI,WAAWC,SAASkG,GAAS,IAE1ClS,OAAOmS,OAAOxG,EAAOI,WAAY,CAC/BiG,SACAE,WAEJ,CClYA,SAASE,EAAS1G,GAChB,IAuBIjC,EACA4I,GAxBA,OACF1G,EAAM,aACNC,EAAY,GACZ3D,EAAE,KACF4D,EAAI,OACJoB,GACEvB,EACJC,EAAO8F,SAAW,CAChBa,SAAS,EACTC,QAAQ,EACRC,SAAU,GAEZ5G,EAAa,CACX6F,SAAU,CACRzF,SAAS,EACTyG,MAAO,IACPC,mBAAmB,EACnBC,sBAAsB,EACtBC,iBAAiB,EACjBC,kBAAkB,EAClBC,mBAAmB,KAKvB,IAEIC,EAEAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EAVAC,EAAqBtG,GAAUA,EAAOwE,SAAWxE,EAAOwE,SAASgB,MAAQ,IACzEe,EAAuBvG,GAAUA,EAAOwE,SAAWxE,EAAOwE,SAASgB,MAAQ,IAE3EgB,GAAoB,IAAIzJ,MAAO2D,UAQnC,SAAS+F,EAAgB/Q,GAClBgJ,IAAUA,EAAOgI,WAAchI,EAAOsG,WACvCtP,EAAEnD,SAAWmM,EAAOsG,YACxBtG,EAAOsG,UAAU/J,oBAAoB,gBAAiBwL,GAClDJ,GAGJM,IACF,CACA,MAAMC,EAAeA,KACnB,GAAIlI,EAAOgI,YAAchI,EAAO8F,SAASa,QAAS,OAC9C3G,EAAO8F,SAASc,OAClBS,GAAY,EACHA,IACTQ,EAAuBT,EACvBC,GAAY,GAEd,MAAMR,EAAW7G,EAAO8F,SAASc,OAASQ,EAAmBU,EAAoBD,GAAuB,IAAIxJ,MAAO2D,UACnHhC,EAAO8F,SAASe,SAAWA,EAC3B3G,EAAK,mBAAoB2G,EAAUA,EAAWe,GAC9ClB,EAAMyB,uBAAsB,KAC1BD,GAAc,GACd,EAaEE,EAAMC,IACV,GAAIrI,EAAOgI,YAAchI,EAAO8F,SAASa,QAAS,OAClD2B,qBAAqB5B,GACrBwB,IACA,IAAIpB,EAA8B,qBAAfuB,EAA6BrI,EAAOsB,OAAOwE,SAASgB,MAAQuB,EAC/ET,EAAqB5H,EAAOsB,OAAOwE,SAASgB,MAC5Ce,EAAuB7H,EAAOsB,OAAOwE,SAASgB,MAC9C,MAAMyB,EAlBcC,MACpB,IAAIC,EAMJ,GAJEA,EADEzI,EAAO0I,SAAW1I,EAAOsB,OAAOoH,QAAQrI,QAC1BL,EAAO2I,OAAOC,QAAOC,GAAWA,EAAQC,UAAUrG,SAAS,yBAAwB,GAEnFzC,EAAO2I,OAAO3I,EAAO+I,cAElCN,EAAe,OAEpB,OAD0BO,SAASP,EAAczM,aAAa,wBAAyB,GAC/D,EASEwM,IACrBS,OAAOC,MAAMX,IAAsBA,EAAoB,GAA2B,qBAAfF,IACtEvB,EAAQyB,EACRX,EAAqBW,EACrBV,EAAuBU,GAEzBnB,EAAmBN,EACnB,MAAMjB,EAAQ7F,EAAOsB,OAAOuE,MACtBsD,EAAUA,KACTnJ,IAAUA,EAAOgI,YAClBhI,EAAOsB,OAAOwE,SAASoB,kBACpBlH,EAAO8B,aAAe9B,EAAOsB,OAAOI,MAAQ1B,EAAOsB,OAAO8H,QAC7DpJ,EAAO+B,UAAU8D,GAAO,GAAM,GAC9B3F,EAAK,aACKF,EAAOsB,OAAOwE,SAASmB,kBACjCjH,EAAOqJ,QAAQrJ,EAAO2I,OAAO3U,OAAS,EAAG6R,GAAO,GAAM,GACtD3F,EAAK,cAGFF,EAAOyB,OAASzB,EAAOsB,OAAOI,MAAQ1B,EAAOsB,OAAO8H,QACvDpJ,EAAO4B,UAAUiE,GAAO,GAAM,GAC9B3F,EAAK,aACKF,EAAOsB,OAAOwE,SAASmB,kBACjCjH,EAAOqJ,QAAQ,EAAGxD,GAAO,GAAM,GAC/B3F,EAAK,aAGLF,EAAOsB,OAAOe,UAChByF,GAAoB,IAAIzJ,MAAO2D,UAC/BmG,uBAAsB,KACpBC,GAAK,KAET,EAcF,OAZItB,EAAQ,GACVjH,aAAa/B,GACbA,EAAUQ,YAAW,KACnB6K,GAAS,GACRrC,IAEHqB,uBAAsB,KACpBgB,GAAS,IAKNrC,CAAK,EAERwC,EAAQA,KACZxB,GAAoB,IAAIzJ,MAAO2D,UAC/BhC,EAAO8F,SAASa,SAAU,EAC1ByB,IACAlI,EAAK,gBAAgB,EAEjB8F,EAAOA,KACXhG,EAAO8F,SAASa,SAAU,EAC1B9G,aAAa/B,GACbwK,qBAAqB5B,GACrBxG,EAAK,eAAe,EAEhBqJ,EAAQA,CAACC,EAAUC,KACvB,GAAIzJ,EAAOgI,YAAchI,EAAO8F,SAASa,QAAS,OAClD9G,aAAa/B,GACR0L,IACH9B,GAAsB,GAExB,MAAMyB,EAAUA,KACdjJ,EAAK,iBACDF,EAAOsB,OAAOwE,SAASiB,kBACzB/G,EAAOsG,UAAUvP,iBAAiB,gBAAiBgR,GAEnDE,GACF,EAGF,GADAjI,EAAO8F,SAASc,QAAS,EACrB6C,EAMF,OALIhC,IACFL,EAAmBpH,EAAOsB,OAAOwE,SAASgB,OAE5CW,GAAe,OACf0B,IAGF,MAAMrC,EAAQM,GAAoBpH,EAAOsB,OAAOwE,SAASgB,MACzDM,EAAmBN,IAAS,IAAIzI,MAAO2D,UAAY8F,GAC/C9H,EAAOyB,OAAS2F,EAAmB,IAAMpH,EAAOsB,OAAOI,OACvD0F,EAAmB,IAAGA,EAAmB,GAC7C+B,IAAS,EAELlB,EAASA,KACTjI,EAAOyB,OAAS2F,EAAmB,IAAMpH,EAAOsB,OAAOI,MAAQ1B,EAAOgI,YAAchI,EAAO8F,SAASa,UACxGmB,GAAoB,IAAIzJ,MAAO2D,UAC3B0F,GACFA,GAAsB,EACtBU,EAAIhB,IAEJgB,IAEFpI,EAAO8F,SAASc,QAAS,EACzB1G,EAAK,kBAAiB,EAElBwJ,EAAqBA,KACzB,GAAI1J,EAAOgI,YAAchI,EAAO8F,SAASa,QAAS,OAClD,MAAM9O,GAAW8R,EAAAA,EAAAA,KACgB,WAA7B9R,EAAS+R,kBACXlC,GAAsB,EACtB6B,GAAM,IAEyB,YAA7B1R,EAAS+R,iBACX3B,GACF,EAEI4B,EAAiB7S,IACC,UAAlBA,EAAE8S,cACNpC,GAAsB,EACtBC,GAAuB,EACnB3H,EAAO2B,WAAa3B,EAAO8F,SAASc,QACxC2C,GAAM,GAAK,EAEPQ,EAAiB/S,IACC,UAAlBA,EAAE8S,cACNnC,GAAuB,EACnB3H,EAAO8F,SAASc,QAClBqB,IACF,EAoBF3L,EAAG,QAAQ,KACL0D,EAAOsB,OAAOwE,SAASzF,UAlBvBL,EAAOsB,OAAOwE,SAASqB,oBACzBnH,EAAOtB,GAAG3H,iBAAiB,eAAgB8S,GAC3C7J,EAAOtB,GAAG3H,iBAAiB,eAAgBgT,KAQ5BJ,EAAAA,EAAAA,KACR5S,iBAAiB,mBAAoB2S,GAU5CJ,IACF,IAEFhN,EAAG,WAAW,KAlBZ0D,EAAOtB,GAAGnC,oBAAoB,eAAgBsN,GAC9C7J,EAAOtB,GAAGnC,oBAAoB,eAAgBwN,IAO7BJ,EAAAA,EAAAA,KACRpN,oBAAoB,mBAAoBmN,GAY7C1J,EAAO8F,SAASa,SAClBX,GACF,IAEF1J,EAAG,0BAA0B,MACvBiL,GAAiBG,IACnBO,GACF,IAEF3L,EAAG,8BAA8B,KAC1B0D,EAAOsB,OAAOwE,SAASkB,qBAG1BhB,IAFAuD,GAAM,GAAM,EAGd,IAEFjN,EAAG,yBAAyB,CAAC0N,EAAInE,EAAO2D,MAClCxJ,EAAOgI,WAAchI,EAAO8F,SAASa,UACrC6C,IAAaxJ,EAAOsB,OAAOwE,SAASkB,qBACtCuC,GAAM,GAAM,GAEZvD,IACF,IAEF1J,EAAG,mBAAmB,MAChB0D,EAAOgI,WAAchI,EAAO8F,SAASa,UACrC3G,EAAOsB,OAAOwE,SAASkB,qBACzBhB,KAGFsB,GAAY,EACZC,GAAgB,EAChBG,GAAsB,EACtBF,EAAoBlJ,YAAW,KAC7BoJ,GAAsB,EACtBH,GAAgB,EAChBgC,GAAM,EAAK,GACV,MAAI,IAETjN,EAAG,YAAY,KACb,IAAI0D,EAAOgI,WAAchI,EAAO8F,SAASa,SAAYW,EAArD,CAGA,GAFAzH,aAAa2H,GACb3H,aAAa/B,GACTkC,EAAOsB,OAAOwE,SAASkB,qBAGzB,OAFAO,GAAgB,OAChBD,GAAY,GAGVC,GAAiBvH,EAAOsB,OAAOe,SAAS4F,IAC5CV,GAAgB,EAChBD,GAAY,CAV0D,CAUrD,IAEnBhL,EAAG,eAAe,MACZ0D,EAAOgI,WAAchI,EAAO8F,SAASa,UACzCc,GAAe,EAAI,IAErBpT,OAAOmS,OAAOxG,EAAO8F,SAAU,CAC7BwD,QACAtD,OACAuD,QACAtB,UAEJ,CCzSA,SAASxD,EAAS1E,GAChB,IAAI,OACFC,EAAM,aACNC,EAAY,KACZC,EAAI,KACJ9F,GACE2F,EACJE,EAAa,CACXwE,SAAU,CACRpE,SAAS,EACT4J,UAAU,EACVC,cAAe,EACfC,gBAAgB,EAChBC,oBAAqB,EACrBC,sBAAuB,EACvB/E,QAAQ,EACRgF,gBAAiB,OAiNrBjW,OAAOmS,OAAOxG,EAAQ,CACpByE,SAAU,CACR8F,aAhNJ,WACE,GAAIvK,EAAOsB,OAAOe,QAAS,OAC3B,MAAMmI,EAAYxK,EAAOoE,eACzBpE,EAAOgF,aAAawF,GACpBxK,EAAO+E,cAAc,GACrB/E,EAAOyK,gBAAgBC,WAAW1W,OAAS,EAC3CgM,EAAOyE,SAASkG,WAAW,CACzBC,WAAY5K,EAAO6K,IAAM7K,EAAOwK,WAAaxK,EAAOwK,WAExD,EAwMIM,YAvMJ,WACE,GAAI9K,EAAOsB,OAAOe,QAAS,OAC3B,MACEoI,gBAAiB5H,EAAI,QACrBkI,GACE/K,EAE2B,IAA3B6C,EAAK6H,WAAW1W,QAClB6O,EAAK6H,WAAWrQ,KAAK,CACnB4E,SAAU8L,EAAQ/K,EAAOiE,eAAiB,SAAW,UACrDS,KAAM7B,EAAKmI,iBAGfnI,EAAK6H,WAAWrQ,KAAK,CACnB4E,SAAU8L,EAAQ/K,EAAOiE,eAAiB,WAAa,YACvDS,MAAM9E,EAAAA,EAAAA,MAEV,EAuLI+K,WAtLJ,SAAoBM,GAClB,IAAI,WACFL,GACEK,EACJ,GAAIjL,EAAOsB,OAAOe,QAAS,OAC3B,MAAM,OACJf,EAAM,UACNgF,EACA1D,aAAciI,EAAG,SACjBK,EACAT,gBAAiB5H,GACf7C,EAGEmL,GADevL,EAAAA,EAAAA,KACWiD,EAAKmI,eACrC,GAAIJ,GAAc5K,EAAOqE,eACvBrE,EAAOqJ,QAAQrJ,EAAO+I,kBAGxB,GAAI6B,GAAc5K,EAAOsE,eACnBtE,EAAO2I,OAAO3U,OAASkX,EAASlX,OAClCgM,EAAOqJ,QAAQ6B,EAASlX,OAAS,GAEjCgM,EAAOqJ,QAAQrJ,EAAO2I,OAAO3U,OAAS,OAJ1C,CAQA,GAAIsN,EAAOmD,SAASwF,SAAU,CAC5B,GAAIpH,EAAK6H,WAAW1W,OAAS,EAAG,CAC9B,MAAMoX,EAAgBvI,EAAK6H,WAAWW,MAChCC,EAAgBzI,EAAK6H,WAAWW,MAChCE,EAAWH,EAAcnM,SAAWqM,EAAcrM,SAClDyF,EAAO0G,EAAc1G,KAAO4G,EAAc5G,KAChD1E,EAAOwL,SAAWD,EAAW7G,EAC7B1E,EAAOwL,UAAY,EACfxS,KAAKkL,IAAIlE,EAAOwL,UAAYlK,EAAOmD,SAAS6F,kBAC9CtK,EAAOwL,SAAW,IAIhB9G,EAAO,MAAO9E,EAAAA,EAAAA,KAAQwL,EAAc1G,KAAO,OAC7C1E,EAAOwL,SAAW,EAEtB,MACExL,EAAOwL,SAAW,EAEpBxL,EAAOwL,UAAYlK,EAAOmD,SAAS4F,sBACnCxH,EAAK6H,WAAW1W,OAAS,EACzB,IAAIyX,EAAmB,IAAOnK,EAAOmD,SAASyF,cAC9C,MAAMwB,EAAmB1L,EAAOwL,SAAWC,EAC3C,IAAIE,EAAc3L,EAAOwK,UAAYkB,EACjCb,IAAKc,GAAeA,GACxB,IACIC,EADAC,GAAW,EAEf,MAAMC,EAA2C,GAA5B9S,KAAKkL,IAAIlE,EAAOwL,UAAiBlK,EAAOmD,SAAS2F,oBACtE,IAAI2B,EACJ,GAAIJ,EAAc3L,EAAOsE,eACnBhD,EAAOmD,SAAS0F,gBACdwB,EAAc3L,EAAOsE,gBAAkBwH,IACzCH,EAAc3L,EAAOsE,eAAiBwH,GAExCF,EAAsB5L,EAAOsE,eAC7BuH,GAAW,EACXhJ,EAAKmJ,qBAAsB,GAE3BL,EAAc3L,EAAOsE,eAEnBhD,EAAOI,MAAQJ,EAAO2K,iBAAgBF,GAAe,QACpD,GAAIJ,EAAc3L,EAAOqE,eAC1B/C,EAAOmD,SAAS0F,gBACdwB,EAAc3L,EAAOqE,eAAiByH,IACxCH,EAAc3L,EAAOqE,eAAiByH,GAExCF,EAAsB5L,EAAOqE,eAC7BwH,GAAW,EACXhJ,EAAKmJ,qBAAsB,GAE3BL,EAAc3L,EAAOqE,eAEnB/C,EAAOI,MAAQJ,EAAO2K,iBAAgBF,GAAe,QACpD,GAAIzK,EAAOmD,SAASa,OAAQ,CACjC,IAAI4G,EACJ,IAAK,IAAIC,EAAI,EAAGA,EAAIjB,EAASlX,OAAQmY,GAAK,EACxC,GAAIjB,EAASiB,IAAMR,EAAa,CAC9BO,EAAYC,EACZ,KACF,CAGAR,EADE3S,KAAKkL,IAAIgH,EAASgB,GAAaP,GAAe3S,KAAKkL,IAAIgH,EAASgB,EAAY,GAAKP,IAA0C,SAA1B3L,EAAOoM,eAC5FlB,EAASgB,GAEThB,EAASgB,EAAY,GAErCP,GAAeA,CACjB,CAOA,GANII,GACF3R,EAAK,iBAAiB,KACpB4F,EAAOoF,SAAS,IAII,IAApBpF,EAAOwL,UAMT,GAJEC,EADEZ,EACiB7R,KAAKkL,MAAMyH,EAAc3L,EAAOwK,WAAaxK,EAAOwL,UAEpDxS,KAAKkL,KAAKyH,EAAc3L,EAAOwK,WAAaxK,EAAOwL,UAEpElK,EAAOmD,SAASa,OAAQ,CAQ1B,MAAM+G,EAAerT,KAAKkL,KAAK2G,GAAOc,EAAcA,GAAe3L,EAAOwK,WACpE8B,EAAmBtM,EAAOuM,gBAAgBvM,EAAO+I,aAErD0C,EADEY,EAAeC,EACEhL,EAAOuE,MACjBwG,EAAe,EAAIC,EACM,IAAfhL,EAAOuE,MAEQ,IAAfvE,EAAOuE,KAE9B,OACK,GAAIvE,EAAOmD,SAASa,OAEzB,YADAtF,EAAO4F,iBAGLtE,EAAOmD,SAAS0F,gBAAkB0B,GACpC7L,EAAOiF,eAAe2G,GACtB5L,EAAO+E,cAAc0G,GACrBzL,EAAOgF,aAAa2G,GACpB3L,EAAOwM,iBAAgB,EAAMxM,EAAOoM,gBACpCpM,EAAO2B,WAAY,GACnB8K,EAAAA,EAAAA,GAAqBnG,GAAW,KACzBtG,IAAUA,EAAOgI,WAAcnF,EAAKmJ,sBACzC9L,EAAK,kBACLF,EAAO+E,cAAczD,EAAOuE,OAC5BvH,YAAW,KACT0B,EAAOgF,aAAa4G,IACpBa,EAAAA,EAAAA,GAAqBnG,GAAW,KACzBtG,IAAUA,EAAOgI,WACtBhI,EAAO0M,eAAe,GACtB,GACD,GAAE,KAEE1M,EAAOwL,UAChBtL,EAAK,8BACLF,EAAOiF,eAAe0G,GACtB3L,EAAO+E,cAAc0G,GACrBzL,EAAOgF,aAAa2G,GACpB3L,EAAOwM,iBAAgB,EAAMxM,EAAOoM,gBAC/BpM,EAAO2B,YACV3B,EAAO2B,WAAY,GACnB8K,EAAAA,EAAAA,GAAqBnG,GAAW,KACzBtG,IAAUA,EAAOgI,WACtBhI,EAAO0M,eAAe,MAI1B1M,EAAOiF,eAAe0G,GAExB3L,EAAOkF,oBACPlF,EAAOmF,qBACT,KAAO,IAAI7D,EAAOmD,SAASa,OAEzB,YADAtF,EAAO4F,iBAEEtE,EAAOmD,UAChBvE,EAAK,6BACP,GACKoB,EAAOmD,SAASwF,UAAYkB,GAAY7J,EAAOqL,gBAClDzM,EAAK,0BACLF,EAAOiF,iBACPjF,EAAOkF,oBACPlF,EAAOmF,sBArJT,CAuJF,IAQF,C","sources":["../node_modules/react-lazyload/lib/index.js","../node_modules/react-lazyload/lib/utils/debounce.js","../node_modules/react-lazyload/lib/utils/event.js","../node_modules/react-lazyload/lib/utils/scrollParent.js","../node_modules/react-lazyload/lib/utils/throttle.js","../node_modules/swiper/modules/mousewheel.mjs","../node_modules/swiper/modules/autoplay.mjs","../node_modules/swiper/modules/free-mode.mjs"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.forceVisible = exports.forceCheck = exports.lazyload = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _event = require('./utils/event');\n\nvar _scrollParent = require('./utils/scrollParent');\n\nvar _scrollParent2 = _interopRequireDefault(_scrollParent);\n\nvar _debounce = require('./utils/debounce');\n\nvar _debounce2 = _interopRequireDefault(_debounce);\n\nvar _throttle = require('./utils/throttle');\n\nvar _throttle2 = _interopRequireDefault(_throttle);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * react-lazyload\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */\n\n\nvar defaultBoundingClientRect = {\n  top: 0,\n  right: 0,\n  bottom: 0,\n  left: 0,\n  width: 0,\n  height: 0\n};\nvar LISTEN_FLAG = 'data-lazyload-listened';\nvar listeners = [];\nvar pending = [];\n\n// try to handle passive events\nvar passiveEventSupported = false;\ntry {\n  var opts = Object.defineProperty({}, 'passive', {\n    get: function get() {\n      passiveEventSupported = true;\n    }\n  });\n  window.addEventListener('test', null, opts);\n} catch (e) {}\n// if they are supported, setup the optional params\n// IMPORTANT: FALSE doubles as the default CAPTURE value!\nvar passiveEvent = passiveEventSupported ? { capture: false, passive: true } : false;\n\n/**\n * Check if `component` is visible in overflow container `parent`\n * @param  {node} component React component\n * @param  {node} parent    component's scroll parent\n * @return {bool}\n */\nvar checkOverflowVisible = function checkOverflowVisible(component, parent) {\n  var node = component.ref;\n\n  var parentTop = void 0;\n  var parentLeft = void 0;\n  var parentHeight = void 0;\n  var parentWidth = void 0;\n\n  try {\n    var _parent$getBoundingCl = parent.getBoundingClientRect();\n\n    parentTop = _parent$getBoundingCl.top;\n    parentLeft = _parent$getBoundingCl.left;\n    parentHeight = _parent$getBoundingCl.height;\n    parentWidth = _parent$getBoundingCl.width;\n  } catch (e) {\n    parentTop = defaultBoundingClientRect.top;\n    parentLeft = defaultBoundingClientRect.left;\n    parentHeight = defaultBoundingClientRect.height;\n    parentWidth = defaultBoundingClientRect.width;\n  }\n\n  var windowInnerHeight = window.innerHeight || document.documentElement.clientHeight;\n  var windowInnerWidth = window.innerWidth || document.documentElement.clientWidth;\n\n  // calculate top and height of the intersection of the element's scrollParent and viewport\n  var intersectionTop = Math.max(parentTop, 0); // intersection's top relative to viewport\n  var intersectionLeft = Math.max(parentLeft, 0); // intersection's left relative to viewport\n  var intersectionHeight = Math.min(windowInnerHeight, parentTop + parentHeight) - intersectionTop; // height\n  var intersectionWidth = Math.min(windowInnerWidth, parentLeft + parentWidth) - intersectionLeft; // width\n\n  // check whether the element is visible in the intersection\n  var top = void 0;\n  var left = void 0;\n  var height = void 0;\n  var width = void 0;\n\n  try {\n    var _node$getBoundingClie = node.getBoundingClientRect();\n\n    top = _node$getBoundingClie.top;\n    left = _node$getBoundingClie.left;\n    height = _node$getBoundingClie.height;\n    width = _node$getBoundingClie.width;\n  } catch (e) {\n    top = defaultBoundingClientRect.top;\n    left = defaultBoundingClientRect.left;\n    height = defaultBoundingClientRect.height;\n    width = defaultBoundingClientRect.width;\n  }\n\n  var offsetTop = top - intersectionTop; // element's top relative to intersection\n  var offsetLeft = left - intersectionLeft; // element's left relative to intersection\n\n  var offsets = Array.isArray(component.props.offset) ? component.props.offset : [component.props.offset, component.props.offset]; // Be compatible with previous API\n\n  return offsetTop - offsets[0] <= intersectionHeight && offsetTop + height + offsets[1] >= 0 && offsetLeft - offsets[0] <= intersectionWidth && offsetLeft + width + offsets[1] >= 0;\n};\n\n/**\n * Check if `component` is visible in document\n * @param  {node} component React component\n * @return {bool}\n */\nvar checkNormalVisible = function checkNormalVisible(component) {\n  var node = component.ref;\n\n  // If this element is hidden by css rules somehow, it's definitely invisible\n  if (!(node.offsetWidth || node.offsetHeight || node.getClientRects().length)) return false;\n\n  var top = void 0;\n  var elementHeight = void 0;\n\n  try {\n    var _node$getBoundingClie2 = node.getBoundingClientRect();\n\n    top = _node$getBoundingClie2.top;\n    elementHeight = _node$getBoundingClie2.height;\n  } catch (e) {\n    top = defaultBoundingClientRect.top;\n    elementHeight = defaultBoundingClientRect.height;\n  }\n\n  var windowInnerHeight = window.innerHeight || document.documentElement.clientHeight;\n\n  var offsets = Array.isArray(component.props.offset) ? component.props.offset : [component.props.offset, component.props.offset]; // Be compatible with previous API\n\n  return top - offsets[0] <= windowInnerHeight && top + elementHeight + offsets[1] >= 0;\n};\n\n/**\n * Detect if element is visible in viewport, if so, set `visible` state to true.\n * If `once` prop is provided true, remove component as listener after checkVisible\n *\n * @param  {React} component   React component that respond to scroll and resize\n */\nvar checkVisible = function checkVisible(component) {\n  var node = component.ref;\n  if (!(node instanceof HTMLElement)) {\n    return;\n  }\n\n  var parent = (0, _scrollParent2.default)(node);\n  var isOverflow = component.props.overflow && parent !== node.ownerDocument && parent !== document && parent !== document.documentElement;\n  var visible = isOverflow ? checkOverflowVisible(component, parent) : checkNormalVisible(component);\n  if (visible) {\n    // Avoid extra render if previously is visible\n    if (!component.visible) {\n      if (component.props.once) {\n        pending.push(component);\n      }\n\n      component.visible = true;\n      component.forceUpdate();\n    }\n  } else if (!(component.props.once && component.visible)) {\n    component.visible = false;\n    if (component.props.unmountIfInvisible) {\n      component.forceUpdate();\n    }\n  }\n};\n\nvar purgePending = function purgePending() {\n  pending.forEach(function (component) {\n    var index = listeners.indexOf(component);\n    if (index !== -1) {\n      listeners.splice(index, 1);\n    }\n  });\n\n  pending = [];\n};\n\nvar lazyLoadHandler = function lazyLoadHandler() {\n  for (var i = 0; i < listeners.length; ++i) {\n    var listener = listeners[i];\n    checkVisible(listener);\n  }\n  // Remove `once` component in listeners\n  purgePending();\n};\n\n/**\n * Forces the component to display regardless of whether the element is visible in the viewport.\n */\nvar forceVisible = function forceVisible() {\n  for (var i = 0; i < listeners.length; ++i) {\n    var listener = listeners[i];\n    listener.visible = true;\n    listener.forceUpdate();\n  }\n  // Remove `once` component in listeners\n  purgePending();\n};\n\n// Depending on component's props\nvar delayType = void 0;\nvar finalLazyLoadHandler = null;\n\nvar isString = function isString(string) {\n  return typeof string === 'string';\n};\n\nvar LazyLoad = function (_Component) {\n  _inherits(LazyLoad, _Component);\n\n  function LazyLoad(props) {\n    _classCallCheck(this, LazyLoad);\n\n    var _this = _possibleConstructorReturn(this, (LazyLoad.__proto__ || Object.getPrototypeOf(LazyLoad)).call(this, props));\n\n    _this.visible = false;\n    _this.setRef = _this.setRef.bind(_this);\n    return _this;\n  }\n\n  _createClass(LazyLoad, [{\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      // It's unlikely to change delay type on the fly, this is mainly\n      // designed for tests\n      var scrollport = window;\n      var scrollContainer = this.props.scrollContainer;\n\n      if (scrollContainer) {\n        if (isString(scrollContainer)) {\n          scrollport = scrollport.document.querySelector(scrollContainer);\n        }\n      }\n      var needResetFinalLazyLoadHandler = this.props.debounce !== undefined && delayType === 'throttle' || delayType === 'debounce' && this.props.debounce === undefined;\n\n      if (needResetFinalLazyLoadHandler) {\n        (0, _event.off)(scrollport, 'scroll', finalLazyLoadHandler, passiveEvent);\n        (0, _event.off)(window, 'resize', finalLazyLoadHandler, passiveEvent);\n        finalLazyLoadHandler = null;\n      }\n\n      if (!finalLazyLoadHandler) {\n        if (this.props.debounce !== undefined) {\n          finalLazyLoadHandler = (0, _debounce2.default)(lazyLoadHandler, typeof this.props.debounce === 'number' ? this.props.debounce : 300);\n          delayType = 'debounce';\n        } else if (this.props.throttle !== undefined) {\n          finalLazyLoadHandler = (0, _throttle2.default)(lazyLoadHandler, typeof this.props.throttle === 'number' ? this.props.throttle : 300);\n          delayType = 'throttle';\n        } else {\n          finalLazyLoadHandler = lazyLoadHandler;\n        }\n      }\n\n      if (this.props.overflow) {\n        var parent = (0, _scrollParent2.default)(this.ref);\n        if (parent && typeof parent.getAttribute === 'function') {\n          var listenerCount = 1 + +parent.getAttribute(LISTEN_FLAG);\n          if (listenerCount === 1) {\n            parent.addEventListener('scroll', finalLazyLoadHandler, passiveEvent);\n          }\n          parent.setAttribute(LISTEN_FLAG, listenerCount);\n        }\n      } else if (listeners.length === 0 || needResetFinalLazyLoadHandler) {\n        var _props = this.props,\n            scroll = _props.scroll,\n            resize = _props.resize;\n\n\n        if (scroll) {\n          (0, _event.on)(scrollport, 'scroll', finalLazyLoadHandler, passiveEvent);\n        }\n\n        if (resize) {\n          (0, _event.on)(window, 'resize', finalLazyLoadHandler, passiveEvent);\n        }\n      }\n\n      listeners.push(this);\n      checkVisible(this);\n    }\n  }, {\n    key: 'shouldComponentUpdate',\n    value: function shouldComponentUpdate() {\n      return this.visible;\n    }\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      if (this.props.overflow) {\n        var parent = (0, _scrollParent2.default)(this.ref);\n        if (parent && typeof parent.getAttribute === 'function') {\n          var listenerCount = +parent.getAttribute(LISTEN_FLAG) - 1;\n          if (listenerCount === 0) {\n            parent.removeEventListener('scroll', finalLazyLoadHandler, passiveEvent);\n            parent.removeAttribute(LISTEN_FLAG);\n          } else {\n            parent.setAttribute(LISTEN_FLAG, listenerCount);\n          }\n        }\n      }\n\n      var index = listeners.indexOf(this);\n      if (index !== -1) {\n        listeners.splice(index, 1);\n      }\n\n      if (listeners.length === 0 && typeof window !== 'undefined') {\n        (0, _event.off)(window, 'resize', finalLazyLoadHandler, passiveEvent);\n        (0, _event.off)(window, 'scroll', finalLazyLoadHandler, passiveEvent);\n      }\n    }\n  }, {\n    key: 'setRef',\n    value: function setRef(element) {\n      if (element) {\n        this.ref = element;\n      }\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _props2 = this.props,\n          height = _props2.height,\n          children = _props2.children,\n          placeholder = _props2.placeholder,\n          className = _props2.className,\n          classNamePrefix = _props2.classNamePrefix,\n          style = _props2.style;\n\n\n      return _react2.default.createElement(\n        'div',\n        { className: classNamePrefix + '-wrapper ' + className, ref: this.setRef, style: style },\n        this.visible ? children : placeholder ? placeholder : _react2.default.createElement('div', {\n          style: { height: height },\n          className: classNamePrefix + '-placeholder'\n        })\n      );\n    }\n  }]);\n\n  return LazyLoad;\n}(_react.Component);\n\nLazyLoad.propTypes = {\n  className: _propTypes2.default.string,\n  classNamePrefix: _propTypes2.default.string,\n  once: _propTypes2.default.bool,\n  height: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.string]),\n  offset: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.arrayOf(_propTypes2.default.number)]),\n  overflow: _propTypes2.default.bool,\n  resize: _propTypes2.default.bool,\n  scroll: _propTypes2.default.bool,\n  children: _propTypes2.default.node,\n  throttle: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.bool]),\n  debounce: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.bool]),\n  placeholder: _propTypes2.default.node,\n  scrollContainer: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.object]),\n  unmountIfInvisible: _propTypes2.default.bool,\n  style: _propTypes2.default.object\n};\n\nLazyLoad.defaultProps = {\n  className: '',\n  classNamePrefix: 'lazyload',\n  once: false,\n  offset: 0,\n  overflow: false,\n  resize: false,\n  scroll: true,\n  unmountIfInvisible: false\n};\n\nvar getDisplayName = function getDisplayName(WrappedComponent) {\n  return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n};\n\nvar decorator = function decorator() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return function lazyload(WrappedComponent) {\n    return function (_Component2) {\n      _inherits(LazyLoadDecorated, _Component2);\n\n      function LazyLoadDecorated() {\n        _classCallCheck(this, LazyLoadDecorated);\n\n        var _this2 = _possibleConstructorReturn(this, (LazyLoadDecorated.__proto__ || Object.getPrototypeOf(LazyLoadDecorated)).call(this));\n\n        _this2.displayName = 'LazyLoad' + getDisplayName(WrappedComponent);\n        return _this2;\n      }\n\n      _createClass(LazyLoadDecorated, [{\n        key: 'render',\n        value: function render() {\n          return _react2.default.createElement(\n            LazyLoad,\n            options,\n            _react2.default.createElement(WrappedComponent, this.props)\n          );\n        }\n      }]);\n\n      return LazyLoadDecorated;\n    }(_react.Component);\n  };\n};\n\nexports.lazyload = decorator;\nexports.default = LazyLoad;\nexports.forceCheck = lazyLoadHandler;\nexports.forceVisible = forceVisible;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = debounce;\nfunction debounce(func, wait, immediate) {\n  var timeout = void 0;\n  var args = void 0;\n  var context = void 0;\n  var timestamp = void 0;\n  var result = void 0;\n\n  var later = function later() {\n    var last = +new Date() - timestamp;\n\n    if (last < wait && last >= 0) {\n      timeout = setTimeout(later, wait - last);\n    } else {\n      timeout = null;\n      if (!immediate) {\n        result = func.apply(context, args);\n        if (!timeout) {\n          context = null;\n          args = null;\n        }\n      }\n    }\n  };\n\n  return function debounced() {\n    context = this;\n    args = arguments;\n    timestamp = +new Date();\n\n    var callNow = immediate && !timeout;\n    if (!timeout) {\n      timeout = setTimeout(later, wait);\n    }\n\n    if (callNow) {\n      result = func.apply(context, args);\n      context = null;\n      args = null;\n    }\n\n    return result;\n  };\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.on = on;\nexports.off = off;\nfunction on(el, eventName, callback, opts) {\n  opts = opts || false;\n  if (el.addEventListener) {\n    el.addEventListener(eventName, callback, opts);\n  } else if (el.attachEvent) {\n    el.attachEvent(\"on\" + eventName, function (e) {\n      callback.call(el, e || window.event);\n    });\n  }\n}\n\nfunction off(el, eventName, callback, opts) {\n  opts = opts || false;\n  if (el.removeEventListener) {\n    el.removeEventListener(eventName, callback, opts);\n  } else if (el.detachEvent) {\n    el.detachEvent(\"on\" + eventName, callback);\n  }\n}","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\n/**\n * @fileOverview Find scroll parent\n */\n\nexports.default = function (node) {\n  if (!(node instanceof HTMLElement)) {\n    return document.documentElement;\n  }\n\n  var excludeStaticParent = node.style.position === 'absolute';\n  var overflowRegex = /(scroll|auto)/;\n  var parent = node;\n\n  while (parent) {\n    if (!parent.parentNode) {\n      return node.ownerDocument || document.documentElement;\n    }\n\n    var style = window.getComputedStyle(parent);\n    var position = style.position;\n    var overflow = style.overflow;\n    var overflowX = style['overflow-x'];\n    var overflowY = style['overflow-y'];\n\n    if (position === 'static' && excludeStaticParent) {\n      parent = parent.parentNode;\n      continue;\n    }\n\n    if (overflowRegex.test(overflow) && overflowRegex.test(overflowX) && overflowRegex.test(overflowY)) {\n      return parent;\n    }\n\n    parent = parent.parentNode;\n  }\n\n  return node.ownerDocument || node.documentElement || document.documentElement;\n};","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = throttle;\n/*eslint-disable */\nfunction throttle(fn, threshhold, scope) {\n  threshhold || (threshhold = 250);\n  var last, deferTimer;\n  return function () {\n    var context = scope || this;\n\n    var now = +new Date(),\n        args = arguments;\n    if (last && now < last + threshhold) {\n      // hold on to it\n      clearTimeout(deferTimer);\n      deferTimer = setTimeout(function () {\n        last = now;\n        fn.apply(context, args);\n      }, threshhold);\n    } else {\n      last = now;\n      fn.apply(context, args);\n    }\n  };\n}","import { a as getWindow } from '../shared/ssr-window.esm.mjs';\nimport { n as nextTick, d as now } from '../shared/utils.mjs';\n\n/* eslint-disable consistent-return */\nfunction Mousewheel(_ref) {\n  let {\n    swiper,\n    extendParams,\n    on,\n    emit\n  } = _ref;\n  const window = getWindow();\n  extendParams({\n    mousewheel: {\n      enabled: false,\n      releaseOnEdges: false,\n      invert: false,\n      forceToAxis: false,\n      sensitivity: 1,\n      eventsTarget: 'container',\n      thresholdDelta: null,\n      thresholdTime: null,\n      noMousewheelClass: 'swiper-no-mousewheel'\n    }\n  });\n  swiper.mousewheel = {\n    enabled: false\n  };\n  let timeout;\n  let lastScrollTime = now();\n  let lastEventBeforeSnap;\n  const recentWheelEvents = [];\n  function normalize(e) {\n    // Reasonable defaults\n    const PIXEL_STEP = 10;\n    const LINE_HEIGHT = 40;\n    const PAGE_HEIGHT = 800;\n    let sX = 0;\n    let sY = 0; // spinX, spinY\n    let pX = 0;\n    let pY = 0; // pixelX, pixelY\n\n    // Legacy\n    if ('detail' in e) {\n      sY = e.detail;\n    }\n    if ('wheelDelta' in e) {\n      sY = -e.wheelDelta / 120;\n    }\n    if ('wheelDeltaY' in e) {\n      sY = -e.wheelDeltaY / 120;\n    }\n    if ('wheelDeltaX' in e) {\n      sX = -e.wheelDeltaX / 120;\n    }\n\n    // side scrolling on FF with DOMMouseScroll\n    if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {\n      sX = sY;\n      sY = 0;\n    }\n    pX = sX * PIXEL_STEP;\n    pY = sY * PIXEL_STEP;\n    if ('deltaY' in e) {\n      pY = e.deltaY;\n    }\n    if ('deltaX' in e) {\n      pX = e.deltaX;\n    }\n    if (e.shiftKey && !pX) {\n      // if user scrolls with shift he wants horizontal scroll\n      pX = pY;\n      pY = 0;\n    }\n    if ((pX || pY) && e.deltaMode) {\n      if (e.deltaMode === 1) {\n        // delta in LINE units\n        pX *= LINE_HEIGHT;\n        pY *= LINE_HEIGHT;\n      } else {\n        // delta in PAGE units\n        pX *= PAGE_HEIGHT;\n        pY *= PAGE_HEIGHT;\n      }\n    }\n\n    // Fall-back if spin cannot be determined\n    if (pX && !sX) {\n      sX = pX < 1 ? -1 : 1;\n    }\n    if (pY && !sY) {\n      sY = pY < 1 ? -1 : 1;\n    }\n    return {\n      spinX: sX,\n      spinY: sY,\n      pixelX: pX,\n      pixelY: pY\n    };\n  }\n  function handleMouseEnter() {\n    if (!swiper.enabled) return;\n    swiper.mouseEntered = true;\n  }\n  function handleMouseLeave() {\n    if (!swiper.enabled) return;\n    swiper.mouseEntered = false;\n  }\n  function animateSlider(newEvent) {\n    if (swiper.params.mousewheel.thresholdDelta && newEvent.delta < swiper.params.mousewheel.thresholdDelta) {\n      // Prevent if delta of wheel scroll delta is below configured threshold\n      return false;\n    }\n    if (swiper.params.mousewheel.thresholdTime && now() - lastScrollTime < swiper.params.mousewheel.thresholdTime) {\n      // Prevent if time between scrolls is below configured threshold\n      return false;\n    }\n\n    // If the movement is NOT big enough and\n    // if the last time the user scrolled was too close to the current one (avoid continuously triggering the slider):\n    //   Don't go any further (avoid insignificant scroll movement).\n    if (newEvent.delta >= 6 && now() - lastScrollTime < 60) {\n      // Return false as a default\n      return true;\n    }\n    // If user is scrolling towards the end:\n    //   If the slider hasn't hit the latest slide or\n    //   if the slider is a loop and\n    //   if the slider isn't moving right now:\n    //     Go to next slide and\n    //     emit a scroll event.\n    // Else (the user is scrolling towards the beginning) and\n    // if the slider hasn't hit the first slide or\n    // if the slider is a loop and\n    // if the slider isn't moving right now:\n    //   Go to prev slide and\n    //   emit a scroll event.\n    if (newEvent.direction < 0) {\n      if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {\n        swiper.slideNext();\n        emit('scroll', newEvent.raw);\n      }\n    } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {\n      swiper.slidePrev();\n      emit('scroll', newEvent.raw);\n    }\n    // If you got here is because an animation has been triggered so store the current time\n    lastScrollTime = new window.Date().getTime();\n    // Return false as a default\n    return false;\n  }\n  function releaseScroll(newEvent) {\n    const params = swiper.params.mousewheel;\n    if (newEvent.direction < 0) {\n      if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {\n        // Return true to animate scroll on edges\n        return true;\n      }\n    } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {\n      // Return true to animate scroll on edges\n      return true;\n    }\n    return false;\n  }\n  function handle(event) {\n    let e = event;\n    let disableParentSwiper = true;\n    if (!swiper.enabled) return;\n\n    // Ignore event if the target or its parents have the swiper-no-mousewheel class\n    if (event.target.closest(`.${swiper.params.mousewheel.noMousewheelClass}`)) return;\n    const params = swiper.params.mousewheel;\n    if (swiper.params.cssMode) {\n      e.preventDefault();\n    }\n    let targetEl = swiper.el;\n    if (swiper.params.mousewheel.eventsTarget !== 'container') {\n      targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);\n    }\n    const targetElContainsTarget = targetEl && targetEl.contains(e.target);\n    if (!swiper.mouseEntered && !targetElContainsTarget && !params.releaseOnEdges) return true;\n    if (e.originalEvent) e = e.originalEvent; // jquery fix\n    let delta = 0;\n    const rtlFactor = swiper.rtlTranslate ? -1 : 1;\n    const data = normalize(e);\n    if (params.forceToAxis) {\n      if (swiper.isHorizontal()) {\n        if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = -data.pixelX * rtlFactor;else return true;\n      } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = -data.pixelY;else return true;\n    } else {\n      delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;\n    }\n    if (delta === 0) return true;\n    if (params.invert) delta = -delta;\n\n    // Get the scroll positions\n    let positions = swiper.getTranslate() + delta * params.sensitivity;\n    if (positions >= swiper.minTranslate()) positions = swiper.minTranslate();\n    if (positions <= swiper.maxTranslate()) positions = swiper.maxTranslate();\n\n    // When loop is true:\n    //     the disableParentSwiper will be true.\n    // When loop is false:\n    //     if the scroll positions is not on edge,\n    //     then the disableParentSwiper will be true.\n    //     if the scroll on edge positions,\n    //     then the disableParentSwiper will be false.\n    disableParentSwiper = swiper.params.loop ? true : !(positions === swiper.minTranslate() || positions === swiper.maxTranslate());\n    if (disableParentSwiper && swiper.params.nested) e.stopPropagation();\n    if (!swiper.params.freeMode || !swiper.params.freeMode.enabled) {\n      // Register the new event in a variable which stores the relevant data\n      const newEvent = {\n        time: now(),\n        delta: Math.abs(delta),\n        direction: Math.sign(delta),\n        raw: event\n      };\n\n      // Keep the most recent events\n      if (recentWheelEvents.length >= 2) {\n        recentWheelEvents.shift(); // only store the last N events\n      }\n\n      const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;\n      recentWheelEvents.push(newEvent);\n\n      // If there is at least one previous recorded event:\n      //   If direction has changed or\n      //   if the scroll is quicker than the previous one:\n      //     Animate the slider.\n      // Else (this is the first time the wheel is moved):\n      //     Animate the slider.\n      if (prevEvent) {\n        if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) {\n          animateSlider(newEvent);\n        }\n      } else {\n        animateSlider(newEvent);\n      }\n\n      // If it's time to release the scroll:\n      //   Return now so you don't hit the preventDefault.\n      if (releaseScroll(newEvent)) {\n        return true;\n      }\n    } else {\n      // Freemode or scrollContainer:\n\n      // If we recently snapped after a momentum scroll, then ignore wheel events\n      // to give time for the deceleration to finish. Stop ignoring after 500 msecs\n      // or if it's a new scroll (larger delta or inverse sign as last event before\n      // an end-of-momentum snap).\n      const newEvent = {\n        time: now(),\n        delta: Math.abs(delta),\n        direction: Math.sign(delta)\n      };\n      const ignoreWheelEvents = lastEventBeforeSnap && newEvent.time < lastEventBeforeSnap.time + 500 && newEvent.delta <= lastEventBeforeSnap.delta && newEvent.direction === lastEventBeforeSnap.direction;\n      if (!ignoreWheelEvents) {\n        lastEventBeforeSnap = undefined;\n        let position = swiper.getTranslate() + delta * params.sensitivity;\n        const wasBeginning = swiper.isBeginning;\n        const wasEnd = swiper.isEnd;\n        if (position >= swiper.minTranslate()) position = swiper.minTranslate();\n        if (position <= swiper.maxTranslate()) position = swiper.maxTranslate();\n        swiper.setTransition(0);\n        swiper.setTranslate(position);\n        swiper.updateProgress();\n        swiper.updateActiveIndex();\n        swiper.updateSlidesClasses();\n        if (!wasBeginning && swiper.isBeginning || !wasEnd && swiper.isEnd) {\n          swiper.updateSlidesClasses();\n        }\n        if (swiper.params.loop) {\n          swiper.loopFix({\n            direction: newEvent.direction < 0 ? 'next' : 'prev',\n            byMousewheel: true\n          });\n        }\n        if (swiper.params.freeMode.sticky) {\n          // When wheel scrolling starts with sticky (aka snap) enabled, then detect\n          // the end of a momentum scroll by storing recent (N=15?) wheel events.\n          // 1. do all N events have decreasing or same (absolute value) delta?\n          // 2. did all N events arrive in the last M (M=500?) msecs?\n          // 3. does the earliest event have an (absolute value) delta that's\n          //    at least P (P=1?) larger than the most recent event's delta?\n          // 4. does the latest event have a delta that's smaller than Q (Q=6?) pixels?\n          // If 1-4 are \"yes\" then we're near the end of a momentum scroll deceleration.\n          // Snap immediately and ignore remaining wheel events in this scroll.\n          // See comment above for \"remaining wheel events in this scroll\" determination.\n          // If 1-4 aren't satisfied, then wait to snap until 500ms after the last event.\n          clearTimeout(timeout);\n          timeout = undefined;\n          if (recentWheelEvents.length >= 15) {\n            recentWheelEvents.shift(); // only store the last N events\n          }\n\n          const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;\n          const firstEvent = recentWheelEvents[0];\n          recentWheelEvents.push(newEvent);\n          if (prevEvent && (newEvent.delta > prevEvent.delta || newEvent.direction !== prevEvent.direction)) {\n            // Increasing or reverse-sign delta means the user started scrolling again. Clear the wheel event log.\n            recentWheelEvents.splice(0);\n          } else if (recentWheelEvents.length >= 15 && newEvent.time - firstEvent.time < 500 && firstEvent.delta - newEvent.delta >= 1 && newEvent.delta <= 6) {\n            // We're at the end of the deceleration of a momentum scroll, so there's no need\n            // to wait for more events. Snap ASAP on the next tick.\n            // Also, because there's some remaining momentum we'll bias the snap in the\n            // direction of the ongoing scroll because it's better UX for the scroll to snap\n            // in the same direction as the scroll instead of reversing to snap.  Therefore,\n            // if it's already scrolled more than 20% in the current direction, keep going.\n            const snapToThreshold = delta > 0 ? 0.8 : 0.2;\n            lastEventBeforeSnap = newEvent;\n            recentWheelEvents.splice(0);\n            timeout = nextTick(() => {\n              swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);\n            }, 0); // no delay; move on next tick\n          }\n\n          if (!timeout) {\n            // if we get here, then we haven't detected the end of a momentum scroll, so\n            // we'll consider a scroll \"complete\" when there haven't been any wheel events\n            // for 500ms.\n            timeout = nextTick(() => {\n              const snapToThreshold = 0.5;\n              lastEventBeforeSnap = newEvent;\n              recentWheelEvents.splice(0);\n              swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);\n            }, 500);\n          }\n        }\n\n        // Emit event\n        if (!ignoreWheelEvents) emit('scroll', e);\n\n        // Stop autoplay\n        if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) swiper.autoplay.stop();\n        // Return page scroll on edge positions\n        if (params.releaseOnEdges && (position === swiper.minTranslate() || position === swiper.maxTranslate())) {\n          return true;\n        }\n      }\n    }\n    if (e.preventDefault) e.preventDefault();else e.returnValue = false;\n    return false;\n  }\n  function events(method) {\n    let targetEl = swiper.el;\n    if (swiper.params.mousewheel.eventsTarget !== 'container') {\n      targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);\n    }\n    targetEl[method]('mouseenter', handleMouseEnter);\n    targetEl[method]('mouseleave', handleMouseLeave);\n    targetEl[method]('wheel', handle);\n  }\n  function enable() {\n    if (swiper.params.cssMode) {\n      swiper.wrapperEl.removeEventListener('wheel', handle);\n      return true;\n    }\n    if (swiper.mousewheel.enabled) return false;\n    events('addEventListener');\n    swiper.mousewheel.enabled = true;\n    return true;\n  }\n  function disable() {\n    if (swiper.params.cssMode) {\n      swiper.wrapperEl.addEventListener(event, handle);\n      return true;\n    }\n    if (!swiper.mousewheel.enabled) return false;\n    events('removeEventListener');\n    swiper.mousewheel.enabled = false;\n    return true;\n  }\n  on('init', () => {\n    if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {\n      disable();\n    }\n    if (swiper.params.mousewheel.enabled) enable();\n  });\n  on('destroy', () => {\n    if (swiper.params.cssMode) {\n      enable();\n    }\n    if (swiper.mousewheel.enabled) disable();\n  });\n  Object.assign(swiper.mousewheel, {\n    enable,\n    disable\n  });\n}\n\nexport { Mousewheel as default };\n","import { g as getDocument } from '../shared/ssr-window.esm.mjs';\n\n/* eslint no-underscore-dangle: \"off\" */\n/* eslint no-use-before-define: \"off\" */\nfunction Autoplay(_ref) {\n  let {\n    swiper,\n    extendParams,\n    on,\n    emit,\n    params\n  } = _ref;\n  swiper.autoplay = {\n    running: false,\n    paused: false,\n    timeLeft: 0\n  };\n  extendParams({\n    autoplay: {\n      enabled: false,\n      delay: 3000,\n      waitForTransition: true,\n      disableOnInteraction: false,\n      stopOnLastSlide: false,\n      reverseDirection: false,\n      pauseOnMouseEnter: false\n    }\n  });\n  let timeout;\n  let raf;\n  let autoplayDelayTotal = params && params.autoplay ? params.autoplay.delay : 3000;\n  let autoplayDelayCurrent = params && params.autoplay ? params.autoplay.delay : 3000;\n  let autoplayTimeLeft;\n  let autoplayStartTime = new Date().getTime();\n  let wasPaused;\n  let isTouched;\n  let pausedByTouch;\n  let touchStartTimeout;\n  let slideChanged;\n  let pausedByInteraction;\n  let pausedByPointerEnter;\n  function onTransitionEnd(e) {\n    if (!swiper || swiper.destroyed || !swiper.wrapperEl) return;\n    if (e.target !== swiper.wrapperEl) return;\n    swiper.wrapperEl.removeEventListener('transitionend', onTransitionEnd);\n    if (pausedByPointerEnter) {\n      return;\n    }\n    resume();\n  }\n  const calcTimeLeft = () => {\n    if (swiper.destroyed || !swiper.autoplay.running) return;\n    if (swiper.autoplay.paused) {\n      wasPaused = true;\n    } else if (wasPaused) {\n      autoplayDelayCurrent = autoplayTimeLeft;\n      wasPaused = false;\n    }\n    const timeLeft = swiper.autoplay.paused ? autoplayTimeLeft : autoplayStartTime + autoplayDelayCurrent - new Date().getTime();\n    swiper.autoplay.timeLeft = timeLeft;\n    emit('autoplayTimeLeft', timeLeft, timeLeft / autoplayDelayTotal);\n    raf = requestAnimationFrame(() => {\n      calcTimeLeft();\n    });\n  };\n  const getSlideDelay = () => {\n    let activeSlideEl;\n    if (swiper.virtual && swiper.params.virtual.enabled) {\n      activeSlideEl = swiper.slides.filter(slideEl => slideEl.classList.contains('swiper-slide-active'))[0];\n    } else {\n      activeSlideEl = swiper.slides[swiper.activeIndex];\n    }\n    if (!activeSlideEl) return undefined;\n    const currentSlideDelay = parseInt(activeSlideEl.getAttribute('data-swiper-autoplay'), 10);\n    return currentSlideDelay;\n  };\n  const run = delayForce => {\n    if (swiper.destroyed || !swiper.autoplay.running) return;\n    cancelAnimationFrame(raf);\n    calcTimeLeft();\n    let delay = typeof delayForce === 'undefined' ? swiper.params.autoplay.delay : delayForce;\n    autoplayDelayTotal = swiper.params.autoplay.delay;\n    autoplayDelayCurrent = swiper.params.autoplay.delay;\n    const currentSlideDelay = getSlideDelay();\n    if (!Number.isNaN(currentSlideDelay) && currentSlideDelay > 0 && typeof delayForce === 'undefined') {\n      delay = currentSlideDelay;\n      autoplayDelayTotal = currentSlideDelay;\n      autoplayDelayCurrent = currentSlideDelay;\n    }\n    autoplayTimeLeft = delay;\n    const speed = swiper.params.speed;\n    const proceed = () => {\n      if (!swiper || swiper.destroyed) return;\n      if (swiper.params.autoplay.reverseDirection) {\n        if (!swiper.isBeginning || swiper.params.loop || swiper.params.rewind) {\n          swiper.slidePrev(speed, true, true);\n          emit('autoplay');\n        } else if (!swiper.params.autoplay.stopOnLastSlide) {\n          swiper.slideTo(swiper.slides.length - 1, speed, true, true);\n          emit('autoplay');\n        }\n      } else {\n        if (!swiper.isEnd || swiper.params.loop || swiper.params.rewind) {\n          swiper.slideNext(speed, true, true);\n          emit('autoplay');\n        } else if (!swiper.params.autoplay.stopOnLastSlide) {\n          swiper.slideTo(0, speed, true, true);\n          emit('autoplay');\n        }\n      }\n      if (swiper.params.cssMode) {\n        autoplayStartTime = new Date().getTime();\n        requestAnimationFrame(() => {\n          run();\n        });\n      }\n    };\n    if (delay > 0) {\n      clearTimeout(timeout);\n      timeout = setTimeout(() => {\n        proceed();\n      }, delay);\n    } else {\n      requestAnimationFrame(() => {\n        proceed();\n      });\n    }\n\n    // eslint-disable-next-line\n    return delay;\n  };\n  const start = () => {\n    autoplayStartTime = new Date().getTime();\n    swiper.autoplay.running = true;\n    run();\n    emit('autoplayStart');\n  };\n  const stop = () => {\n    swiper.autoplay.running = false;\n    clearTimeout(timeout);\n    cancelAnimationFrame(raf);\n    emit('autoplayStop');\n  };\n  const pause = (internal, reset) => {\n    if (swiper.destroyed || !swiper.autoplay.running) return;\n    clearTimeout(timeout);\n    if (!internal) {\n      pausedByInteraction = true;\n    }\n    const proceed = () => {\n      emit('autoplayPause');\n      if (swiper.params.autoplay.waitForTransition) {\n        swiper.wrapperEl.addEventListener('transitionend', onTransitionEnd);\n      } else {\n        resume();\n      }\n    };\n    swiper.autoplay.paused = true;\n    if (reset) {\n      if (slideChanged) {\n        autoplayTimeLeft = swiper.params.autoplay.delay;\n      }\n      slideChanged = false;\n      proceed();\n      return;\n    }\n    const delay = autoplayTimeLeft || swiper.params.autoplay.delay;\n    autoplayTimeLeft = delay - (new Date().getTime() - autoplayStartTime);\n    if (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop) return;\n    if (autoplayTimeLeft < 0) autoplayTimeLeft = 0;\n    proceed();\n  };\n  const resume = () => {\n    if (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop || swiper.destroyed || !swiper.autoplay.running) return;\n    autoplayStartTime = new Date().getTime();\n    if (pausedByInteraction) {\n      pausedByInteraction = false;\n      run(autoplayTimeLeft);\n    } else {\n      run();\n    }\n    swiper.autoplay.paused = false;\n    emit('autoplayResume');\n  };\n  const onVisibilityChange = () => {\n    if (swiper.destroyed || !swiper.autoplay.running) return;\n    const document = getDocument();\n    if (document.visibilityState === 'hidden') {\n      pausedByInteraction = true;\n      pause(true);\n    }\n    if (document.visibilityState === 'visible') {\n      resume();\n    }\n  };\n  const onPointerEnter = e => {\n    if (e.pointerType !== 'mouse') return;\n    pausedByInteraction = true;\n    pausedByPointerEnter = true;\n    if (swiper.animating || swiper.autoplay.paused) return;\n    pause(true);\n  };\n  const onPointerLeave = e => {\n    if (e.pointerType !== 'mouse') return;\n    pausedByPointerEnter = false;\n    if (swiper.autoplay.paused) {\n      resume();\n    }\n  };\n  const attachMouseEvents = () => {\n    if (swiper.params.autoplay.pauseOnMouseEnter) {\n      swiper.el.addEventListener('pointerenter', onPointerEnter);\n      swiper.el.addEventListener('pointerleave', onPointerLeave);\n    }\n  };\n  const detachMouseEvents = () => {\n    swiper.el.removeEventListener('pointerenter', onPointerEnter);\n    swiper.el.removeEventListener('pointerleave', onPointerLeave);\n  };\n  const attachDocumentEvents = () => {\n    const document = getDocument();\n    document.addEventListener('visibilitychange', onVisibilityChange);\n  };\n  const detachDocumentEvents = () => {\n    const document = getDocument();\n    document.removeEventListener('visibilitychange', onVisibilityChange);\n  };\n  on('init', () => {\n    if (swiper.params.autoplay.enabled) {\n      attachMouseEvents();\n      attachDocumentEvents();\n      start();\n    }\n  });\n  on('destroy', () => {\n    detachMouseEvents();\n    detachDocumentEvents();\n    if (swiper.autoplay.running) {\n      stop();\n    }\n  });\n  on('_freeModeStaticRelease', () => {\n    if (pausedByTouch || pausedByInteraction) {\n      resume();\n    }\n  });\n  on('_freeModeNoMomentumRelease', () => {\n    if (!swiper.params.autoplay.disableOnInteraction) {\n      pause(true, true);\n    } else {\n      stop();\n    }\n  });\n  on('beforeTransitionStart', (_s, speed, internal) => {\n    if (swiper.destroyed || !swiper.autoplay.running) return;\n    if (internal || !swiper.params.autoplay.disableOnInteraction) {\n      pause(true, true);\n    } else {\n      stop();\n    }\n  });\n  on('sliderFirstMove', () => {\n    if (swiper.destroyed || !swiper.autoplay.running) return;\n    if (swiper.params.autoplay.disableOnInteraction) {\n      stop();\n      return;\n    }\n    isTouched = true;\n    pausedByTouch = false;\n    pausedByInteraction = false;\n    touchStartTimeout = setTimeout(() => {\n      pausedByInteraction = true;\n      pausedByTouch = true;\n      pause(true);\n    }, 200);\n  });\n  on('touchEnd', () => {\n    if (swiper.destroyed || !swiper.autoplay.running || !isTouched) return;\n    clearTimeout(touchStartTimeout);\n    clearTimeout(timeout);\n    if (swiper.params.autoplay.disableOnInteraction) {\n      pausedByTouch = false;\n      isTouched = false;\n      return;\n    }\n    if (pausedByTouch && swiper.params.cssMode) resume();\n    pausedByTouch = false;\n    isTouched = false;\n  });\n  on('slideChange', () => {\n    if (swiper.destroyed || !swiper.autoplay.running) return;\n    slideChanged = true;\n  });\n  Object.assign(swiper.autoplay, {\n    start,\n    stop,\n    pause,\n    resume\n  });\n}\n\nexport { Autoplay as default };\n","import { d as now, j as elementTransitionEnd } from '../shared/utils.mjs';\n\nfunction freeMode(_ref) {\n  let {\n    swiper,\n    extendParams,\n    emit,\n    once\n  } = _ref;\n  extendParams({\n    freeMode: {\n      enabled: false,\n      momentum: true,\n      momentumRatio: 1,\n      momentumBounce: true,\n      momentumBounceRatio: 1,\n      momentumVelocityRatio: 1,\n      sticky: false,\n      minimumVelocity: 0.02\n    }\n  });\n  function onTouchStart() {\n    if (swiper.params.cssMode) return;\n    const translate = swiper.getTranslate();\n    swiper.setTranslate(translate);\n    swiper.setTransition(0);\n    swiper.touchEventsData.velocities.length = 0;\n    swiper.freeMode.onTouchEnd({\n      currentPos: swiper.rtl ? swiper.translate : -swiper.translate\n    });\n  }\n  function onTouchMove() {\n    if (swiper.params.cssMode) return;\n    const {\n      touchEventsData: data,\n      touches\n    } = swiper;\n    // Velocity\n    if (data.velocities.length === 0) {\n      data.velocities.push({\n        position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],\n        time: data.touchStartTime\n      });\n    }\n    data.velocities.push({\n      position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],\n      time: now()\n    });\n  }\n  function onTouchEnd(_ref2) {\n    let {\n      currentPos\n    } = _ref2;\n    if (swiper.params.cssMode) return;\n    const {\n      params,\n      wrapperEl,\n      rtlTranslate: rtl,\n      snapGrid,\n      touchEventsData: data\n    } = swiper;\n    // Time diff\n    const touchEndTime = now();\n    const timeDiff = touchEndTime - data.touchStartTime;\n    if (currentPos < -swiper.minTranslate()) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n    if (currentPos > -swiper.maxTranslate()) {\n      if (swiper.slides.length < snapGrid.length) {\n        swiper.slideTo(snapGrid.length - 1);\n      } else {\n        swiper.slideTo(swiper.slides.length - 1);\n      }\n      return;\n    }\n    if (params.freeMode.momentum) {\n      if (data.velocities.length > 1) {\n        const lastMoveEvent = data.velocities.pop();\n        const velocityEvent = data.velocities.pop();\n        const distance = lastMoveEvent.position - velocityEvent.position;\n        const time = lastMoveEvent.time - velocityEvent.time;\n        swiper.velocity = distance / time;\n        swiper.velocity /= 2;\n        if (Math.abs(swiper.velocity) < params.freeMode.minimumVelocity) {\n          swiper.velocity = 0;\n        }\n        // this implies that the user stopped moving a finger then released.\n        // There would be no events with distance zero, so the last event is stale.\n        if (time > 150 || now() - lastMoveEvent.time > 300) {\n          swiper.velocity = 0;\n        }\n      } else {\n        swiper.velocity = 0;\n      }\n      swiper.velocity *= params.freeMode.momentumVelocityRatio;\n      data.velocities.length = 0;\n      let momentumDuration = 1000 * params.freeMode.momentumRatio;\n      const momentumDistance = swiper.velocity * momentumDuration;\n      let newPosition = swiper.translate + momentumDistance;\n      if (rtl) newPosition = -newPosition;\n      let doBounce = false;\n      let afterBouncePosition;\n      const bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeMode.momentumBounceRatio;\n      let needsLoopFix;\n      if (newPosition < swiper.maxTranslate()) {\n        if (params.freeMode.momentumBounce) {\n          if (newPosition + swiper.maxTranslate() < -bounceAmount) {\n            newPosition = swiper.maxTranslate() - bounceAmount;\n          }\n          afterBouncePosition = swiper.maxTranslate();\n          doBounce = true;\n          data.allowMomentumBounce = true;\n        } else {\n          newPosition = swiper.maxTranslate();\n        }\n        if (params.loop && params.centeredSlides) needsLoopFix = true;\n      } else if (newPosition > swiper.minTranslate()) {\n        if (params.freeMode.momentumBounce) {\n          if (newPosition - swiper.minTranslate() > bounceAmount) {\n            newPosition = swiper.minTranslate() + bounceAmount;\n          }\n          afterBouncePosition = swiper.minTranslate();\n          doBounce = true;\n          data.allowMomentumBounce = true;\n        } else {\n          newPosition = swiper.minTranslate();\n        }\n        if (params.loop && params.centeredSlides) needsLoopFix = true;\n      } else if (params.freeMode.sticky) {\n        let nextSlide;\n        for (let j = 0; j < snapGrid.length; j += 1) {\n          if (snapGrid[j] > -newPosition) {\n            nextSlide = j;\n            break;\n          }\n        }\n        if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {\n          newPosition = snapGrid[nextSlide];\n        } else {\n          newPosition = snapGrid[nextSlide - 1];\n        }\n        newPosition = -newPosition;\n      }\n      if (needsLoopFix) {\n        once('transitionEnd', () => {\n          swiper.loopFix();\n        });\n      }\n      // Fix duration\n      if (swiper.velocity !== 0) {\n        if (rtl) {\n          momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);\n        } else {\n          momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);\n        }\n        if (params.freeMode.sticky) {\n          // If freeMode.sticky is active and the user ends a swipe with a slow-velocity\n          // event, then durations can be 20+ seconds to slide one (or zero!) slides.\n          // It's easy to see this when simulating touch with mouse events. To fix this,\n          // limit single-slide swipes to the default slide duration. This also has the\n          // nice side effect of matching slide speed if the user stopped moving before\n          // lifting finger or mouse vs. moving slowly before lifting the finger/mouse.\n          // For faster swipes, also apply limits (albeit higher ones).\n          const moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);\n          const currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];\n          if (moveDistance < currentSlideSize) {\n            momentumDuration = params.speed;\n          } else if (moveDistance < 2 * currentSlideSize) {\n            momentumDuration = params.speed * 1.5;\n          } else {\n            momentumDuration = params.speed * 2.5;\n          }\n        }\n      } else if (params.freeMode.sticky) {\n        swiper.slideToClosest();\n        return;\n      }\n      if (params.freeMode.momentumBounce && doBounce) {\n        swiper.updateProgress(afterBouncePosition);\n        swiper.setTransition(momentumDuration);\n        swiper.setTranslate(newPosition);\n        swiper.transitionStart(true, swiper.swipeDirection);\n        swiper.animating = true;\n        elementTransitionEnd(wrapperEl, () => {\n          if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;\n          emit('momentumBounce');\n          swiper.setTransition(params.speed);\n          setTimeout(() => {\n            swiper.setTranslate(afterBouncePosition);\n            elementTransitionEnd(wrapperEl, () => {\n              if (!swiper || swiper.destroyed) return;\n              swiper.transitionEnd();\n            });\n          }, 0);\n        });\n      } else if (swiper.velocity) {\n        emit('_freeModeNoMomentumRelease');\n        swiper.updateProgress(newPosition);\n        swiper.setTransition(momentumDuration);\n        swiper.setTranslate(newPosition);\n        swiper.transitionStart(true, swiper.swipeDirection);\n        if (!swiper.animating) {\n          swiper.animating = true;\n          elementTransitionEnd(wrapperEl, () => {\n            if (!swiper || swiper.destroyed) return;\n            swiper.transitionEnd();\n          });\n        }\n      } else {\n        swiper.updateProgress(newPosition);\n      }\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    } else if (params.freeMode.sticky) {\n      swiper.slideToClosest();\n      return;\n    } else if (params.freeMode) {\n      emit('_freeModeNoMomentumRelease');\n    }\n    if (!params.freeMode.momentum || timeDiff >= params.longSwipesMs) {\n      emit('_freeModeStaticRelease');\n      swiper.updateProgress();\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    }\n  }\n  Object.assign(swiper, {\n    freeMode: {\n      onTouchStart,\n      onTouchMove,\n      onTouchEnd\n    }\n  });\n}\n\nexport { freeMode as default };\n"],"names":["_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","Constructor","protoProps","staticProps","prototype","_react","require","_react2","_interopRequireDefault","_propTypes2","_event","_scrollParent2","_debounce2","_throttle2","obj","__esModule","default","_classCallCheck","instance","TypeError","_possibleConstructorReturn","self","call","ReferenceError","_inherits","subClass","superClass","create","constructor","value","setPrototypeOf","__proto__","defaultBoundingClientRect","LISTEN_FLAG","listeners","pending","passiveEventSupported","opts","get","window","addEventListener","e","passiveEvent","capture","passive","checkVisible","component","node","ref","HTMLElement","parent","visible","overflow","ownerDocument","document","documentElement","parentTop","parentLeft","parentHeight","parentWidth","_parent$getBoundingCl","getBoundingClientRect","top","left","height","width","windowInnerHeight","innerHeight","clientHeight","windowInnerWidth","innerWidth","clientWidth","intersectionTop","Math","max","intersectionLeft","intersectionHeight","min","intersectionWidth","_node$getBoundingClie","offsetTop","offsetLeft","offsets","Array","isArray","offset","checkOverflowVisible","offsetWidth","offsetHeight","getClientRects","elementHeight","_node$getBoundingClie2","checkNormalVisible","once","push","forceUpdate","unmountIfInvisible","purgePending","forEach","index","indexOf","splice","lazyLoadHandler","listener","delayType","finalLazyLoadHandler","LazyLoad","_Component","this","_this","getPrototypeOf","setRef","bind","scrollport","scrollContainer","querySelector","needResetFinalLazyLoadHandler","undefined","debounce","off","throttle","getAttribute","listenerCount","setAttribute","_props","scroll","resize","on","removeEventListener","removeAttribute","element","_props2","children","placeholder","className","classNamePrefix","style","createElement","Component","propTypes","string","bool","oneOfType","number","arrayOf","object","defaultProps","exports","func","wait","immediate","timeout","args","context","timestamp","result","later","last","Date","setTimeout","apply","arguments","callNow","el","eventName","callback","attachEvent","event","detachEvent","excludeStaticParent","position","overflowRegex","parentNode","getComputedStyle","overflowX","overflowY","test","fn","threshhold","scope","deferTimer","now","clearTimeout","Mousewheel","_ref","swiper","extendParams","emit","getWindow","mousewheel","enabled","releaseOnEdges","invert","forceToAxis","sensitivity","eventsTarget","thresholdDelta","thresholdTime","noMousewheelClass","lastEventBeforeSnap","lastScrollTime","recentWheelEvents","handleMouseEnter","mouseEntered","handleMouseLeave","animateSlider","newEvent","params","delta","direction","isEnd","loop","animating","slideNext","raw","isBeginning","slidePrev","getTime","handle","disableParentSwiper","closest","concat","cssMode","preventDefault","targetEl","targetElContainsTarget","contains","originalEvent","rtlFactor","rtlTranslate","data","sX","sY","pX","pY","detail","wheelDelta","wheelDeltaY","wheelDeltaX","axis","HORIZONTAL_AXIS","deltaY","deltaX","shiftKey","deltaMode","spinX","spinY","pixelX","pixelY","normalize","isHorizontal","abs","positions","getTranslate","minTranslate","maxTranslate","nested","stopPropagation","freeMode","time","sign","ignoreWheelEvents","wasBeginning","wasEnd","setTransition","setTranslate","updateProgress","updateActiveIndex","updateSlidesClasses","loopFix","byMousewheel","sticky","shift","prevEvent","firstEvent","snapToThreshold","nextTick","slideToClosest","speed","autoplay","autoplayDisableOnInteraction","stop","releaseScroll","returnValue","events","method","enable","wrapperEl","disable","assign","Autoplay","raf","running","paused","timeLeft","delay","waitForTransition","disableOnInteraction","stopOnLastSlide","reverseDirection","pauseOnMouseEnter","autoplayTimeLeft","wasPaused","isTouched","pausedByTouch","touchStartTimeout","slideChanged","pausedByInteraction","pausedByPointerEnter","autoplayDelayTotal","autoplayDelayCurrent","autoplayStartTime","onTransitionEnd","destroyed","resume","calcTimeLeft","requestAnimationFrame","run","delayForce","cancelAnimationFrame","currentSlideDelay","getSlideDelay","activeSlideEl","virtual","slides","filter","slideEl","classList","activeIndex","parseInt","Number","isNaN","proceed","rewind","slideTo","start","pause","internal","reset","onVisibilityChange","getDocument","visibilityState","onPointerEnter","pointerType","onPointerLeave","_s","momentum","momentumRatio","momentumBounce","momentumBounceRatio","momentumVelocityRatio","minimumVelocity","onTouchStart","translate","touchEventsData","velocities","onTouchEnd","currentPos","rtl","onTouchMove","touches","touchStartTime","_ref2","snapGrid","timeDiff","lastMoveEvent","pop","velocityEvent","distance","velocity","momentumDuration","momentumDistance","newPosition","afterBouncePosition","doBounce","bounceAmount","needsLoopFix","allowMomentumBounce","centeredSlides","nextSlide","j","swipeDirection","moveDistance","currentSlideSize","slidesSizesGrid","transitionStart","elementTransitionEnd","transitionEnd","longSwipesMs"],"sourceRoot":""}